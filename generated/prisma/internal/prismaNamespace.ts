
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/library"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
 * Metrics
 */
export type Metrics = runtime.Metrics
export type Metric<T> = runtime.Metric<T>
export type MetricHistogram = runtime.MetricHistogram
export type MetricHistogramBucket = runtime.MetricHistogramBucket

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 6.19.2
 * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
 */
export const prismaVersion: PrismaVersion = {
  client: "6.19.2",
  engine: "c2990dca591cba766e3b7ef5d9e8a84796e47ab7"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.objectEnumValues.classes.DbNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.DbNull),
  JsonNull: runtime.objectEnumValues.classes.JsonNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.JsonNull),
  AnyNull: runtime.objectEnumValues.classes.AnyNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.objectEnumValues.instances.DbNull
/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.objectEnumValues.instances.JsonNull
/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.objectEnumValues.instances.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Applications: 'Applications',
  Categoria: 'Categoria',
  Categories: 'Categories',
  Comment: 'Comment',
  Configs: 'Configs',
  Departamento: 'Departamento',
  Departments: 'Departments',
  IssIndicadoresMacroeconomicos: 'IssIndicadoresMacroeconomicos',
  IssRecoleccionProyectos: 'IssRecoleccionProyectos',
  Municipalities: 'Municipalities',
  Municipio: 'Municipio',
  Projects: 'Projects',
  ProjectsVersions: 'ProjectsVersions',
  ProyectStatus: 'ProyectStatus',
  Proyecto: 'Proyecto',
  Response: 'Response',
  Statuses: 'Statuses',
  SubCategoria: 'SubCategoria',
  Subcategories: 'Subcategories',
  Unidades: 'Unidades',
  Units: 'Units',
  UnitsVersions: 'UnitsVersions',
  Uso: 'Uso',
  Zona: 'Zona',
  Zones: 'Zones',
  housing_amenities: 'housing_amenities',
  housing_services: 'housing_services',
  housing_units: 'housing_units',
  housing_universe: 'housing_universe',
  industrial_amenities: 'industrial_amenities',
  industrial_units: 'industrial_units',
  industrial_universe: 'industrial_universe',
  issAmenidades: 'issAmenidades',
  office_amenities: 'office_amenities',
  office_units: 'office_units',
  office_universe: 'office_universe'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "applications" | "categoria" | "categories" | "comment" | "configs" | "departamento" | "departments" | "issIndicadoresMacroeconomicos" | "issRecoleccionProyectos" | "municipalities" | "municipio" | "projects" | "projectsVersions" | "proyectStatus" | "proyecto" | "response" | "statuses" | "subCategoria" | "subcategories" | "unidades" | "units" | "unitsVersions" | "uso" | "zona" | "zones" | "housing_amenities" | "housing_services" | "housing_units" | "housing_universe" | "industrial_amenities" | "industrial_units" | "industrial_universe" | "issAmenidades" | "office_amenities" | "office_units" | "office_universe"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Applications: {
      payload: Prisma.$ApplicationsPayload<ExtArgs>
      fields: Prisma.ApplicationsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApplicationsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApplicationsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationsPayload>
        }
        findFirst: {
          args: Prisma.ApplicationsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApplicationsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationsPayload>
        }
        findMany: {
          args: Prisma.ApplicationsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationsPayload>[]
        }
        create: {
          args: Prisma.ApplicationsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationsPayload>
        }
        createMany: {
          args: Prisma.ApplicationsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ApplicationsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationsPayload>
        }
        update: {
          args: Prisma.ApplicationsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationsPayload>
        }
        deleteMany: {
          args: Prisma.ApplicationsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApplicationsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ApplicationsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationsPayload>
        }
        aggregate: {
          args: Prisma.ApplicationsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApplications>
        }
        groupBy: {
          args: Prisma.ApplicationsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationsGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApplicationsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationsCountAggregateOutputType> | number
        }
      }
    }
    Categoria: {
      payload: Prisma.$CategoriaPayload<ExtArgs>
      fields: Prisma.CategoriaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CategoriaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CategoriaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriaPayload>
        }
        findFirst: {
          args: Prisma.CategoriaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CategoriaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriaPayload>
        }
        findMany: {
          args: Prisma.CategoriaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriaPayload>[]
        }
        create: {
          args: Prisma.CategoriaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriaPayload>
        }
        createMany: {
          args: Prisma.CategoriaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.CategoriaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriaPayload>
        }
        update: {
          args: Prisma.CategoriaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriaPayload>
        }
        deleteMany: {
          args: Prisma.CategoriaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CategoriaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.CategoriaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriaPayload>
        }
        aggregate: {
          args: Prisma.CategoriaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCategoria>
        }
        groupBy: {
          args: Prisma.CategoriaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoriaGroupByOutputType>[]
        }
        count: {
          args: Prisma.CategoriaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoriaCountAggregateOutputType> | number
        }
      }
    }
    Categories: {
      payload: Prisma.$CategoriesPayload<ExtArgs>
      fields: Prisma.CategoriesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CategoriesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CategoriesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriesPayload>
        }
        findFirst: {
          args: Prisma.CategoriesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CategoriesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriesPayload>
        }
        findMany: {
          args: Prisma.CategoriesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriesPayload>[]
        }
        create: {
          args: Prisma.CategoriesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriesPayload>
        }
        createMany: {
          args: Prisma.CategoriesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.CategoriesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriesPayload>
        }
        update: {
          args: Prisma.CategoriesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriesPayload>
        }
        deleteMany: {
          args: Prisma.CategoriesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CategoriesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.CategoriesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoriesPayload>
        }
        aggregate: {
          args: Prisma.CategoriesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCategories>
        }
        groupBy: {
          args: Prisma.CategoriesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoriesGroupByOutputType>[]
        }
        count: {
          args: Prisma.CategoriesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoriesCountAggregateOutputType> | number
        }
      }
    }
    Comment: {
      payload: Prisma.$CommentPayload<ExtArgs>
      fields: Prisma.CommentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        findFirst: {
          args: Prisma.CommentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        findMany: {
          args: Prisma.CommentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        create: {
          args: Prisma.CommentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        createMany: {
          args: Prisma.CommentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.CommentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        update: {
          args: Prisma.CommentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        deleteMany: {
          args: Prisma.CommentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.CommentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        aggregate: {
          args: Prisma.CommentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateComment>
        }
        groupBy: {
          args: Prisma.CommentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommentGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommentCountAggregateOutputType> | number
        }
      }
    }
    Configs: {
      payload: Prisma.$ConfigsPayload<ExtArgs>
      fields: Prisma.ConfigsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConfigsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConfigsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigsPayload>
        }
        findFirst: {
          args: Prisma.ConfigsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConfigsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigsPayload>
        }
        findMany: {
          args: Prisma.ConfigsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigsPayload>[]
        }
        create: {
          args: Prisma.ConfigsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigsPayload>
        }
        createMany: {
          args: Prisma.ConfigsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ConfigsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigsPayload>
        }
        update: {
          args: Prisma.ConfigsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigsPayload>
        }
        deleteMany: {
          args: Prisma.ConfigsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConfigsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ConfigsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigsPayload>
        }
        aggregate: {
          args: Prisma.ConfigsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConfigs>
        }
        groupBy: {
          args: Prisma.ConfigsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConfigsGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConfigsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConfigsCountAggregateOutputType> | number
        }
      }
    }
    Departamento: {
      payload: Prisma.$DepartamentoPayload<ExtArgs>
      fields: Prisma.DepartamentoFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DepartamentoFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartamentoPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DepartamentoFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartamentoPayload>
        }
        findFirst: {
          args: Prisma.DepartamentoFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartamentoPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DepartamentoFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartamentoPayload>
        }
        findMany: {
          args: Prisma.DepartamentoFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartamentoPayload>[]
        }
        create: {
          args: Prisma.DepartamentoCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartamentoPayload>
        }
        createMany: {
          args: Prisma.DepartamentoCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DepartamentoDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartamentoPayload>
        }
        update: {
          args: Prisma.DepartamentoUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartamentoPayload>
        }
        deleteMany: {
          args: Prisma.DepartamentoDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DepartamentoUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DepartamentoUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartamentoPayload>
        }
        aggregate: {
          args: Prisma.DepartamentoAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDepartamento>
        }
        groupBy: {
          args: Prisma.DepartamentoGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DepartamentoGroupByOutputType>[]
        }
        count: {
          args: Prisma.DepartamentoCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DepartamentoCountAggregateOutputType> | number
        }
      }
    }
    Departments: {
      payload: Prisma.$DepartmentsPayload<ExtArgs>
      fields: Prisma.DepartmentsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DepartmentsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DepartmentsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentsPayload>
        }
        findFirst: {
          args: Prisma.DepartmentsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DepartmentsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentsPayload>
        }
        findMany: {
          args: Prisma.DepartmentsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentsPayload>[]
        }
        create: {
          args: Prisma.DepartmentsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentsPayload>
        }
        createMany: {
          args: Prisma.DepartmentsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DepartmentsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentsPayload>
        }
        update: {
          args: Prisma.DepartmentsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentsPayload>
        }
        deleteMany: {
          args: Prisma.DepartmentsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DepartmentsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DepartmentsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentsPayload>
        }
        aggregate: {
          args: Prisma.DepartmentsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDepartments>
        }
        groupBy: {
          args: Prisma.DepartmentsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DepartmentsGroupByOutputType>[]
        }
        count: {
          args: Prisma.DepartmentsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DepartmentsCountAggregateOutputType> | number
        }
      }
    }
    IssIndicadoresMacroeconomicos: {
      payload: Prisma.$IssIndicadoresMacroeconomicosPayload<ExtArgs>
      fields: Prisma.IssIndicadoresMacroeconomicosFieldRefs
      operations: {
        findUnique: {
          args: Prisma.IssIndicadoresMacroeconomicosFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssIndicadoresMacroeconomicosPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.IssIndicadoresMacroeconomicosFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssIndicadoresMacroeconomicosPayload>
        }
        findFirst: {
          args: Prisma.IssIndicadoresMacroeconomicosFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssIndicadoresMacroeconomicosPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.IssIndicadoresMacroeconomicosFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssIndicadoresMacroeconomicosPayload>
        }
        findMany: {
          args: Prisma.IssIndicadoresMacroeconomicosFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssIndicadoresMacroeconomicosPayload>[]
        }
        create: {
          args: Prisma.IssIndicadoresMacroeconomicosCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssIndicadoresMacroeconomicosPayload>
        }
        createMany: {
          args: Prisma.IssIndicadoresMacroeconomicosCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.IssIndicadoresMacroeconomicosDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssIndicadoresMacroeconomicosPayload>
        }
        update: {
          args: Prisma.IssIndicadoresMacroeconomicosUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssIndicadoresMacroeconomicosPayload>
        }
        deleteMany: {
          args: Prisma.IssIndicadoresMacroeconomicosDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.IssIndicadoresMacroeconomicosUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.IssIndicadoresMacroeconomicosUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssIndicadoresMacroeconomicosPayload>
        }
        aggregate: {
          args: Prisma.IssIndicadoresMacroeconomicosAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateIssIndicadoresMacroeconomicos>
        }
        groupBy: {
          args: Prisma.IssIndicadoresMacroeconomicosGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IssIndicadoresMacroeconomicosGroupByOutputType>[]
        }
        count: {
          args: Prisma.IssIndicadoresMacroeconomicosCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IssIndicadoresMacroeconomicosCountAggregateOutputType> | number
        }
      }
    }
    IssRecoleccionProyectos: {
      payload: Prisma.$IssRecoleccionProyectosPayload<ExtArgs>
      fields: Prisma.IssRecoleccionProyectosFieldRefs
      operations: {
        findUnique: {
          args: Prisma.IssRecoleccionProyectosFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssRecoleccionProyectosPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.IssRecoleccionProyectosFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssRecoleccionProyectosPayload>
        }
        findFirst: {
          args: Prisma.IssRecoleccionProyectosFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssRecoleccionProyectosPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.IssRecoleccionProyectosFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssRecoleccionProyectosPayload>
        }
        findMany: {
          args: Prisma.IssRecoleccionProyectosFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssRecoleccionProyectosPayload>[]
        }
        create: {
          args: Prisma.IssRecoleccionProyectosCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssRecoleccionProyectosPayload>
        }
        createMany: {
          args: Prisma.IssRecoleccionProyectosCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.IssRecoleccionProyectosDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssRecoleccionProyectosPayload>
        }
        update: {
          args: Prisma.IssRecoleccionProyectosUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssRecoleccionProyectosPayload>
        }
        deleteMany: {
          args: Prisma.IssRecoleccionProyectosDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.IssRecoleccionProyectosUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.IssRecoleccionProyectosUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssRecoleccionProyectosPayload>
        }
        aggregate: {
          args: Prisma.IssRecoleccionProyectosAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateIssRecoleccionProyectos>
        }
        groupBy: {
          args: Prisma.IssRecoleccionProyectosGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IssRecoleccionProyectosGroupByOutputType>[]
        }
        count: {
          args: Prisma.IssRecoleccionProyectosCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IssRecoleccionProyectosCountAggregateOutputType> | number
        }
      }
    }
    Municipalities: {
      payload: Prisma.$MunicipalitiesPayload<ExtArgs>
      fields: Prisma.MunicipalitiesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MunicipalitiesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipalitiesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MunicipalitiesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipalitiesPayload>
        }
        findFirst: {
          args: Prisma.MunicipalitiesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipalitiesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MunicipalitiesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipalitiesPayload>
        }
        findMany: {
          args: Prisma.MunicipalitiesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipalitiesPayload>[]
        }
        create: {
          args: Prisma.MunicipalitiesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipalitiesPayload>
        }
        createMany: {
          args: Prisma.MunicipalitiesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.MunicipalitiesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipalitiesPayload>
        }
        update: {
          args: Prisma.MunicipalitiesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipalitiesPayload>
        }
        deleteMany: {
          args: Prisma.MunicipalitiesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MunicipalitiesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.MunicipalitiesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipalitiesPayload>
        }
        aggregate: {
          args: Prisma.MunicipalitiesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMunicipalities>
        }
        groupBy: {
          args: Prisma.MunicipalitiesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MunicipalitiesGroupByOutputType>[]
        }
        count: {
          args: Prisma.MunicipalitiesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MunicipalitiesCountAggregateOutputType> | number
        }
      }
    }
    Municipio: {
      payload: Prisma.$MunicipioPayload<ExtArgs>
      fields: Prisma.MunicipioFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MunicipioFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipioPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MunicipioFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipioPayload>
        }
        findFirst: {
          args: Prisma.MunicipioFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipioPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MunicipioFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipioPayload>
        }
        findMany: {
          args: Prisma.MunicipioFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipioPayload>[]
        }
        create: {
          args: Prisma.MunicipioCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipioPayload>
        }
        createMany: {
          args: Prisma.MunicipioCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.MunicipioDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipioPayload>
        }
        update: {
          args: Prisma.MunicipioUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipioPayload>
        }
        deleteMany: {
          args: Prisma.MunicipioDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MunicipioUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.MunicipioUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MunicipioPayload>
        }
        aggregate: {
          args: Prisma.MunicipioAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMunicipio>
        }
        groupBy: {
          args: Prisma.MunicipioGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MunicipioGroupByOutputType>[]
        }
        count: {
          args: Prisma.MunicipioCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MunicipioCountAggregateOutputType> | number
        }
      }
    }
    Projects: {
      payload: Prisma.$ProjectsPayload<ExtArgs>
      fields: Prisma.ProjectsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProjectsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProjectsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsPayload>
        }
        findFirst: {
          args: Prisma.ProjectsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProjectsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsPayload>
        }
        findMany: {
          args: Prisma.ProjectsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsPayload>[]
        }
        create: {
          args: Prisma.ProjectsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsPayload>
        }
        createMany: {
          args: Prisma.ProjectsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ProjectsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsPayload>
        }
        update: {
          args: Prisma.ProjectsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsPayload>
        }
        deleteMany: {
          args: Prisma.ProjectsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProjectsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ProjectsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsPayload>
        }
        aggregate: {
          args: Prisma.ProjectsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProjects>
        }
        groupBy: {
          args: Prisma.ProjectsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectsGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProjectsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectsCountAggregateOutputType> | number
        }
      }
    }
    ProjectsVersions: {
      payload: Prisma.$ProjectsVersionsPayload<ExtArgs>
      fields: Prisma.ProjectsVersionsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProjectsVersionsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsVersionsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProjectsVersionsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsVersionsPayload>
        }
        findFirst: {
          args: Prisma.ProjectsVersionsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsVersionsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProjectsVersionsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsVersionsPayload>
        }
        findMany: {
          args: Prisma.ProjectsVersionsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsVersionsPayload>[]
        }
        create: {
          args: Prisma.ProjectsVersionsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsVersionsPayload>
        }
        createMany: {
          args: Prisma.ProjectsVersionsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ProjectsVersionsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsVersionsPayload>
        }
        update: {
          args: Prisma.ProjectsVersionsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsVersionsPayload>
        }
        deleteMany: {
          args: Prisma.ProjectsVersionsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProjectsVersionsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ProjectsVersionsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectsVersionsPayload>
        }
        aggregate: {
          args: Prisma.ProjectsVersionsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProjectsVersions>
        }
        groupBy: {
          args: Prisma.ProjectsVersionsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectsVersionsGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProjectsVersionsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectsVersionsCountAggregateOutputType> | number
        }
      }
    }
    ProyectStatus: {
      payload: Prisma.$ProyectStatusPayload<ExtArgs>
      fields: Prisma.ProyectStatusFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProyectStatusFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectStatusPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProyectStatusFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectStatusPayload>
        }
        findFirst: {
          args: Prisma.ProyectStatusFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectStatusPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProyectStatusFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectStatusPayload>
        }
        findMany: {
          args: Prisma.ProyectStatusFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectStatusPayload>[]
        }
        create: {
          args: Prisma.ProyectStatusCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectStatusPayload>
        }
        createMany: {
          args: Prisma.ProyectStatusCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ProyectStatusDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectStatusPayload>
        }
        update: {
          args: Prisma.ProyectStatusUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectStatusPayload>
        }
        deleteMany: {
          args: Prisma.ProyectStatusDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProyectStatusUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ProyectStatusUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectStatusPayload>
        }
        aggregate: {
          args: Prisma.ProyectStatusAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProyectStatus>
        }
        groupBy: {
          args: Prisma.ProyectStatusGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProyectStatusGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProyectStatusCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProyectStatusCountAggregateOutputType> | number
        }
      }
    }
    Proyecto: {
      payload: Prisma.$ProyectoPayload<ExtArgs>
      fields: Prisma.ProyectoFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProyectoFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectoPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProyectoFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectoPayload>
        }
        findFirst: {
          args: Prisma.ProyectoFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectoPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProyectoFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectoPayload>
        }
        findMany: {
          args: Prisma.ProyectoFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectoPayload>[]
        }
        create: {
          args: Prisma.ProyectoCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectoPayload>
        }
        createMany: {
          args: Prisma.ProyectoCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ProyectoDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectoPayload>
        }
        update: {
          args: Prisma.ProyectoUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectoPayload>
        }
        deleteMany: {
          args: Prisma.ProyectoDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProyectoUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ProyectoUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProyectoPayload>
        }
        aggregate: {
          args: Prisma.ProyectoAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProyecto>
        }
        groupBy: {
          args: Prisma.ProyectoGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProyectoGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProyectoCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProyectoCountAggregateOutputType> | number
        }
      }
    }
    Response: {
      payload: Prisma.$ResponsePayload<ExtArgs>
      fields: Prisma.ResponseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ResponseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResponsePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ResponseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResponsePayload>
        }
        findFirst: {
          args: Prisma.ResponseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResponsePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ResponseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResponsePayload>
        }
        findMany: {
          args: Prisma.ResponseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResponsePayload>[]
        }
        create: {
          args: Prisma.ResponseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResponsePayload>
        }
        createMany: {
          args: Prisma.ResponseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ResponseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResponsePayload>
        }
        update: {
          args: Prisma.ResponseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResponsePayload>
        }
        deleteMany: {
          args: Prisma.ResponseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ResponseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ResponseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResponsePayload>
        }
        aggregate: {
          args: Prisma.ResponseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateResponse>
        }
        groupBy: {
          args: Prisma.ResponseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ResponseGroupByOutputType>[]
        }
        count: {
          args: Prisma.ResponseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ResponseCountAggregateOutputType> | number
        }
      }
    }
    Statuses: {
      payload: Prisma.$StatusesPayload<ExtArgs>
      fields: Prisma.StatusesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StatusesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StatusesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusesPayload>
        }
        findFirst: {
          args: Prisma.StatusesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StatusesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusesPayload>
        }
        findMany: {
          args: Prisma.StatusesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusesPayload>[]
        }
        create: {
          args: Prisma.StatusesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusesPayload>
        }
        createMany: {
          args: Prisma.StatusesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.StatusesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusesPayload>
        }
        update: {
          args: Prisma.StatusesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusesPayload>
        }
        deleteMany: {
          args: Prisma.StatusesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StatusesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.StatusesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatusesPayload>
        }
        aggregate: {
          args: Prisma.StatusesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStatuses>
        }
        groupBy: {
          args: Prisma.StatusesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StatusesGroupByOutputType>[]
        }
        count: {
          args: Prisma.StatusesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StatusesCountAggregateOutputType> | number
        }
      }
    }
    SubCategoria: {
      payload: Prisma.$SubCategoriaPayload<ExtArgs>
      fields: Prisma.SubCategoriaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SubCategoriaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubCategoriaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SubCategoriaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
        }
        findFirst: {
          args: Prisma.SubCategoriaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubCategoriaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SubCategoriaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
        }
        findMany: {
          args: Prisma.SubCategoriaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubCategoriaPayload>[]
        }
        create: {
          args: Prisma.SubCategoriaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
        }
        createMany: {
          args: Prisma.SubCategoriaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.SubCategoriaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
        }
        update: {
          args: Prisma.SubCategoriaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
        }
        deleteMany: {
          args: Prisma.SubCategoriaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SubCategoriaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.SubCategoriaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubCategoriaPayload>
        }
        aggregate: {
          args: Prisma.SubCategoriaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubCategoria>
        }
        groupBy: {
          args: Prisma.SubCategoriaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubCategoriaGroupByOutputType>[]
        }
        count: {
          args: Prisma.SubCategoriaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubCategoriaCountAggregateOutputType> | number
        }
      }
    }
    Subcategories: {
      payload: Prisma.$SubcategoriesPayload<ExtArgs>
      fields: Prisma.SubcategoriesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SubcategoriesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubcategoriesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SubcategoriesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubcategoriesPayload>
        }
        findFirst: {
          args: Prisma.SubcategoriesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubcategoriesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SubcategoriesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubcategoriesPayload>
        }
        findMany: {
          args: Prisma.SubcategoriesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubcategoriesPayload>[]
        }
        create: {
          args: Prisma.SubcategoriesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubcategoriesPayload>
        }
        createMany: {
          args: Prisma.SubcategoriesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.SubcategoriesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubcategoriesPayload>
        }
        update: {
          args: Prisma.SubcategoriesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubcategoriesPayload>
        }
        deleteMany: {
          args: Prisma.SubcategoriesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SubcategoriesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.SubcategoriesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubcategoriesPayload>
        }
        aggregate: {
          args: Prisma.SubcategoriesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubcategories>
        }
        groupBy: {
          args: Prisma.SubcategoriesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubcategoriesGroupByOutputType>[]
        }
        count: {
          args: Prisma.SubcategoriesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubcategoriesCountAggregateOutputType> | number
        }
      }
    }
    Unidades: {
      payload: Prisma.$UnidadesPayload<ExtArgs>
      fields: Prisma.UnidadesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UnidadesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnidadesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UnidadesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnidadesPayload>
        }
        findFirst: {
          args: Prisma.UnidadesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnidadesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UnidadesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnidadesPayload>
        }
        findMany: {
          args: Prisma.UnidadesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnidadesPayload>[]
        }
        create: {
          args: Prisma.UnidadesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnidadesPayload>
        }
        createMany: {
          args: Prisma.UnidadesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.UnidadesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnidadesPayload>
        }
        update: {
          args: Prisma.UnidadesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnidadesPayload>
        }
        deleteMany: {
          args: Prisma.UnidadesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UnidadesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.UnidadesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnidadesPayload>
        }
        aggregate: {
          args: Prisma.UnidadesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUnidades>
        }
        groupBy: {
          args: Prisma.UnidadesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UnidadesGroupByOutputType>[]
        }
        count: {
          args: Prisma.UnidadesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UnidadesCountAggregateOutputType> | number
        }
      }
    }
    Units: {
      payload: Prisma.$UnitsPayload<ExtArgs>
      fields: Prisma.UnitsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UnitsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UnitsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsPayload>
        }
        findFirst: {
          args: Prisma.UnitsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UnitsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsPayload>
        }
        findMany: {
          args: Prisma.UnitsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsPayload>[]
        }
        create: {
          args: Prisma.UnitsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsPayload>
        }
        createMany: {
          args: Prisma.UnitsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.UnitsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsPayload>
        }
        update: {
          args: Prisma.UnitsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsPayload>
        }
        deleteMany: {
          args: Prisma.UnitsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UnitsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.UnitsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsPayload>
        }
        aggregate: {
          args: Prisma.UnitsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUnits>
        }
        groupBy: {
          args: Prisma.UnitsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UnitsGroupByOutputType>[]
        }
        count: {
          args: Prisma.UnitsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UnitsCountAggregateOutputType> | number
        }
      }
    }
    UnitsVersions: {
      payload: Prisma.$UnitsVersionsPayload<ExtArgs>
      fields: Prisma.UnitsVersionsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UnitsVersionsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsVersionsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UnitsVersionsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsVersionsPayload>
        }
        findFirst: {
          args: Prisma.UnitsVersionsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsVersionsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UnitsVersionsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsVersionsPayload>
        }
        findMany: {
          args: Prisma.UnitsVersionsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsVersionsPayload>[]
        }
        create: {
          args: Prisma.UnitsVersionsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsVersionsPayload>
        }
        createMany: {
          args: Prisma.UnitsVersionsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.UnitsVersionsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsVersionsPayload>
        }
        update: {
          args: Prisma.UnitsVersionsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsVersionsPayload>
        }
        deleteMany: {
          args: Prisma.UnitsVersionsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UnitsVersionsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.UnitsVersionsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitsVersionsPayload>
        }
        aggregate: {
          args: Prisma.UnitsVersionsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUnitsVersions>
        }
        groupBy: {
          args: Prisma.UnitsVersionsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UnitsVersionsGroupByOutputType>[]
        }
        count: {
          args: Prisma.UnitsVersionsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UnitsVersionsCountAggregateOutputType> | number
        }
      }
    }
    Uso: {
      payload: Prisma.$UsoPayload<ExtArgs>
      fields: Prisma.UsoFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UsoFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UsoPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UsoFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UsoPayload>
        }
        findFirst: {
          args: Prisma.UsoFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UsoPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UsoFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UsoPayload>
        }
        findMany: {
          args: Prisma.UsoFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UsoPayload>[]
        }
        create: {
          args: Prisma.UsoCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UsoPayload>
        }
        createMany: {
          args: Prisma.UsoCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.UsoDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UsoPayload>
        }
        update: {
          args: Prisma.UsoUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UsoPayload>
        }
        deleteMany: {
          args: Prisma.UsoDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UsoUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.UsoUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UsoPayload>
        }
        aggregate: {
          args: Prisma.UsoAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUso>
        }
        groupBy: {
          args: Prisma.UsoGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UsoGroupByOutputType>[]
        }
        count: {
          args: Prisma.UsoCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UsoCountAggregateOutputType> | number
        }
      }
    }
    Zona: {
      payload: Prisma.$ZonaPayload<ExtArgs>
      fields: Prisma.ZonaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ZonaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ZonaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonaPayload>
        }
        findFirst: {
          args: Prisma.ZonaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ZonaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonaPayload>
        }
        findMany: {
          args: Prisma.ZonaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonaPayload>[]
        }
        create: {
          args: Prisma.ZonaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonaPayload>
        }
        createMany: {
          args: Prisma.ZonaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ZonaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonaPayload>
        }
        update: {
          args: Prisma.ZonaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonaPayload>
        }
        deleteMany: {
          args: Prisma.ZonaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ZonaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ZonaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonaPayload>
        }
        aggregate: {
          args: Prisma.ZonaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateZona>
        }
        groupBy: {
          args: Prisma.ZonaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ZonaGroupByOutputType>[]
        }
        count: {
          args: Prisma.ZonaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ZonaCountAggregateOutputType> | number
        }
      }
    }
    Zones: {
      payload: Prisma.$ZonesPayload<ExtArgs>
      fields: Prisma.ZonesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ZonesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ZonesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload>
        }
        findFirst: {
          args: Prisma.ZonesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ZonesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload>
        }
        findMany: {
          args: Prisma.ZonesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload>[]
        }
        create: {
          args: Prisma.ZonesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload>
        }
        createMany: {
          args: Prisma.ZonesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ZonesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload>
        }
        update: {
          args: Prisma.ZonesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload>
        }
        deleteMany: {
          args: Prisma.ZonesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ZonesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ZonesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZonesPayload>
        }
        aggregate: {
          args: Prisma.ZonesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateZones>
        }
        groupBy: {
          args: Prisma.ZonesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ZonesGroupByOutputType>[]
        }
        count: {
          args: Prisma.ZonesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ZonesCountAggregateOutputType> | number
        }
      }
    }
    housing_amenities: {
      payload: Prisma.$housing_amenitiesPayload<ExtArgs>
      fields: Prisma.housing_amenitiesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.housing_amenitiesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_amenitiesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.housing_amenitiesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_amenitiesPayload>
        }
        findFirst: {
          args: Prisma.housing_amenitiesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_amenitiesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.housing_amenitiesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_amenitiesPayload>
        }
        findMany: {
          args: Prisma.housing_amenitiesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_amenitiesPayload>[]
        }
        create: {
          args: Prisma.housing_amenitiesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_amenitiesPayload>
        }
        createMany: {
          args: Prisma.housing_amenitiesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.housing_amenitiesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_amenitiesPayload>
        }
        update: {
          args: Prisma.housing_amenitiesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_amenitiesPayload>
        }
        deleteMany: {
          args: Prisma.housing_amenitiesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.housing_amenitiesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.housing_amenitiesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_amenitiesPayload>
        }
        aggregate: {
          args: Prisma.Housing_amenitiesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHousing_amenities>
        }
        groupBy: {
          args: Prisma.housing_amenitiesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Housing_amenitiesGroupByOutputType>[]
        }
        count: {
          args: Prisma.housing_amenitiesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Housing_amenitiesCountAggregateOutputType> | number
        }
      }
    }
    housing_services: {
      payload: Prisma.$housing_servicesPayload<ExtArgs>
      fields: Prisma.housing_servicesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.housing_servicesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_servicesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.housing_servicesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_servicesPayload>
        }
        findFirst: {
          args: Prisma.housing_servicesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_servicesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.housing_servicesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_servicesPayload>
        }
        findMany: {
          args: Prisma.housing_servicesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_servicesPayload>[]
        }
        create: {
          args: Prisma.housing_servicesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_servicesPayload>
        }
        createMany: {
          args: Prisma.housing_servicesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.housing_servicesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_servicesPayload>
        }
        update: {
          args: Prisma.housing_servicesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_servicesPayload>
        }
        deleteMany: {
          args: Prisma.housing_servicesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.housing_servicesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.housing_servicesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_servicesPayload>
        }
        aggregate: {
          args: Prisma.Housing_servicesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHousing_services>
        }
        groupBy: {
          args: Prisma.housing_servicesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Housing_servicesGroupByOutputType>[]
        }
        count: {
          args: Prisma.housing_servicesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Housing_servicesCountAggregateOutputType> | number
        }
      }
    }
    housing_units: {
      payload: Prisma.$housing_unitsPayload<ExtArgs>
      fields: Prisma.housing_unitsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.housing_unitsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_unitsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.housing_unitsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_unitsPayload>
        }
        findFirst: {
          args: Prisma.housing_unitsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_unitsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.housing_unitsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_unitsPayload>
        }
        findMany: {
          args: Prisma.housing_unitsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_unitsPayload>[]
        }
        create: {
          args: Prisma.housing_unitsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_unitsPayload>
        }
        createMany: {
          args: Prisma.housing_unitsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.housing_unitsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_unitsPayload>
        }
        update: {
          args: Prisma.housing_unitsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_unitsPayload>
        }
        deleteMany: {
          args: Prisma.housing_unitsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.housing_unitsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.housing_unitsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_unitsPayload>
        }
        aggregate: {
          args: Prisma.Housing_unitsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHousing_units>
        }
        groupBy: {
          args: Prisma.housing_unitsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Housing_unitsGroupByOutputType>[]
        }
        count: {
          args: Prisma.housing_unitsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Housing_unitsCountAggregateOutputType> | number
        }
      }
    }
    housing_universe: {
      payload: Prisma.$housing_universePayload<ExtArgs>
      fields: Prisma.housing_universeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.housing_universeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_universePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.housing_universeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_universePayload>
        }
        findFirst: {
          args: Prisma.housing_universeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_universePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.housing_universeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_universePayload>
        }
        findMany: {
          args: Prisma.housing_universeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_universePayload>[]
        }
        create: {
          args: Prisma.housing_universeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_universePayload>
        }
        createMany: {
          args: Prisma.housing_universeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.housing_universeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_universePayload>
        }
        update: {
          args: Prisma.housing_universeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_universePayload>
        }
        deleteMany: {
          args: Prisma.housing_universeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.housing_universeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.housing_universeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$housing_universePayload>
        }
        aggregate: {
          args: Prisma.Housing_universeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHousing_universe>
        }
        groupBy: {
          args: Prisma.housing_universeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Housing_universeGroupByOutputType>[]
        }
        count: {
          args: Prisma.housing_universeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Housing_universeCountAggregateOutputType> | number
        }
      }
    }
    industrial_amenities: {
      payload: Prisma.$industrial_amenitiesPayload<ExtArgs>
      fields: Prisma.industrial_amenitiesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.industrial_amenitiesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_amenitiesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.industrial_amenitiesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_amenitiesPayload>
        }
        findFirst: {
          args: Prisma.industrial_amenitiesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_amenitiesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.industrial_amenitiesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_amenitiesPayload>
        }
        findMany: {
          args: Prisma.industrial_amenitiesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_amenitiesPayload>[]
        }
        create: {
          args: Prisma.industrial_amenitiesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_amenitiesPayload>
        }
        createMany: {
          args: Prisma.industrial_amenitiesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.industrial_amenitiesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_amenitiesPayload>
        }
        update: {
          args: Prisma.industrial_amenitiesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_amenitiesPayload>
        }
        deleteMany: {
          args: Prisma.industrial_amenitiesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.industrial_amenitiesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.industrial_amenitiesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_amenitiesPayload>
        }
        aggregate: {
          args: Prisma.Industrial_amenitiesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateIndustrial_amenities>
        }
        groupBy: {
          args: Prisma.industrial_amenitiesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Industrial_amenitiesGroupByOutputType>[]
        }
        count: {
          args: Prisma.industrial_amenitiesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Industrial_amenitiesCountAggregateOutputType> | number
        }
      }
    }
    industrial_units: {
      payload: Prisma.$industrial_unitsPayload<ExtArgs>
      fields: Prisma.industrial_unitsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.industrial_unitsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_unitsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.industrial_unitsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_unitsPayload>
        }
        findFirst: {
          args: Prisma.industrial_unitsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_unitsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.industrial_unitsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_unitsPayload>
        }
        findMany: {
          args: Prisma.industrial_unitsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_unitsPayload>[]
        }
        create: {
          args: Prisma.industrial_unitsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_unitsPayload>
        }
        createMany: {
          args: Prisma.industrial_unitsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.industrial_unitsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_unitsPayload>
        }
        update: {
          args: Prisma.industrial_unitsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_unitsPayload>
        }
        deleteMany: {
          args: Prisma.industrial_unitsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.industrial_unitsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.industrial_unitsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_unitsPayload>
        }
        aggregate: {
          args: Prisma.Industrial_unitsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateIndustrial_units>
        }
        groupBy: {
          args: Prisma.industrial_unitsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Industrial_unitsGroupByOutputType>[]
        }
        count: {
          args: Prisma.industrial_unitsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Industrial_unitsCountAggregateOutputType> | number
        }
      }
    }
    industrial_universe: {
      payload: Prisma.$industrial_universePayload<ExtArgs>
      fields: Prisma.industrial_universeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.industrial_universeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_universePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.industrial_universeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_universePayload>
        }
        findFirst: {
          args: Prisma.industrial_universeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_universePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.industrial_universeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_universePayload>
        }
        findMany: {
          args: Prisma.industrial_universeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_universePayload>[]
        }
        create: {
          args: Prisma.industrial_universeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_universePayload>
        }
        createMany: {
          args: Prisma.industrial_universeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.industrial_universeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_universePayload>
        }
        update: {
          args: Prisma.industrial_universeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_universePayload>
        }
        deleteMany: {
          args: Prisma.industrial_universeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.industrial_universeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.industrial_universeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$industrial_universePayload>
        }
        aggregate: {
          args: Prisma.Industrial_universeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateIndustrial_universe>
        }
        groupBy: {
          args: Prisma.industrial_universeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Industrial_universeGroupByOutputType>[]
        }
        count: {
          args: Prisma.industrial_universeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Industrial_universeCountAggregateOutputType> | number
        }
      }
    }
    issAmenidades: {
      payload: Prisma.$issAmenidadesPayload<ExtArgs>
      fields: Prisma.issAmenidadesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.issAmenidadesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$issAmenidadesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.issAmenidadesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$issAmenidadesPayload>
        }
        findFirst: {
          args: Prisma.issAmenidadesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$issAmenidadesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.issAmenidadesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$issAmenidadesPayload>
        }
        findMany: {
          args: Prisma.issAmenidadesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$issAmenidadesPayload>[]
        }
        create: {
          args: Prisma.issAmenidadesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$issAmenidadesPayload>
        }
        createMany: {
          args: Prisma.issAmenidadesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.issAmenidadesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$issAmenidadesPayload>
        }
        update: {
          args: Prisma.issAmenidadesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$issAmenidadesPayload>
        }
        deleteMany: {
          args: Prisma.issAmenidadesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.issAmenidadesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.issAmenidadesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$issAmenidadesPayload>
        }
        aggregate: {
          args: Prisma.IssAmenidadesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateIssAmenidades>
        }
        groupBy: {
          args: Prisma.issAmenidadesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IssAmenidadesGroupByOutputType>[]
        }
        count: {
          args: Prisma.issAmenidadesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IssAmenidadesCountAggregateOutputType> | number
        }
      }
    }
    office_amenities: {
      payload: Prisma.$office_amenitiesPayload<ExtArgs>
      fields: Prisma.office_amenitiesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.office_amenitiesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_amenitiesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.office_amenitiesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_amenitiesPayload>
        }
        findFirst: {
          args: Prisma.office_amenitiesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_amenitiesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.office_amenitiesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_amenitiesPayload>
        }
        findMany: {
          args: Prisma.office_amenitiesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_amenitiesPayload>[]
        }
        create: {
          args: Prisma.office_amenitiesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_amenitiesPayload>
        }
        createMany: {
          args: Prisma.office_amenitiesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.office_amenitiesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_amenitiesPayload>
        }
        update: {
          args: Prisma.office_amenitiesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_amenitiesPayload>
        }
        deleteMany: {
          args: Prisma.office_amenitiesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.office_amenitiesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.office_amenitiesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_amenitiesPayload>
        }
        aggregate: {
          args: Prisma.Office_amenitiesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOffice_amenities>
        }
        groupBy: {
          args: Prisma.office_amenitiesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Office_amenitiesGroupByOutputType>[]
        }
        count: {
          args: Prisma.office_amenitiesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Office_amenitiesCountAggregateOutputType> | number
        }
      }
    }
    office_units: {
      payload: Prisma.$office_unitsPayload<ExtArgs>
      fields: Prisma.office_unitsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.office_unitsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_unitsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.office_unitsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_unitsPayload>
        }
        findFirst: {
          args: Prisma.office_unitsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_unitsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.office_unitsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_unitsPayload>
        }
        findMany: {
          args: Prisma.office_unitsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_unitsPayload>[]
        }
        create: {
          args: Prisma.office_unitsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_unitsPayload>
        }
        createMany: {
          args: Prisma.office_unitsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.office_unitsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_unitsPayload>
        }
        update: {
          args: Prisma.office_unitsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_unitsPayload>
        }
        deleteMany: {
          args: Prisma.office_unitsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.office_unitsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.office_unitsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_unitsPayload>
        }
        aggregate: {
          args: Prisma.Office_unitsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOffice_units>
        }
        groupBy: {
          args: Prisma.office_unitsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Office_unitsGroupByOutputType>[]
        }
        count: {
          args: Prisma.office_unitsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Office_unitsCountAggregateOutputType> | number
        }
      }
    }
    office_universe: {
      payload: Prisma.$office_universePayload<ExtArgs>
      fields: Prisma.office_universeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.office_universeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_universePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.office_universeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_universePayload>
        }
        findFirst: {
          args: Prisma.office_universeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_universePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.office_universeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_universePayload>
        }
        findMany: {
          args: Prisma.office_universeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_universePayload>[]
        }
        create: {
          args: Prisma.office_universeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_universePayload>
        }
        createMany: {
          args: Prisma.office_universeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.office_universeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_universePayload>
        }
        update: {
          args: Prisma.office_universeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_universePayload>
        }
        deleteMany: {
          args: Prisma.office_universeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.office_universeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.office_universeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$office_universePayload>
        }
        aggregate: {
          args: Prisma.Office_universeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOffice_universe>
        }
        groupBy: {
          args: Prisma.office_universeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Office_universeGroupByOutputType>[]
        }
        count: {
          args: Prisma.office_universeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Office_universeCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const ApplicationsScalarFieldEnum = {
  applications_id: 'applications_id',
  applications_name: 'applications_name',
  params: 'params',
  is_active: 'is_active',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type ApplicationsScalarFieldEnum = (typeof ApplicationsScalarFieldEnum)[keyof typeof ApplicationsScalarFieldEnum]


export const CategoriaScalarFieldEnum = {
  id: 'id',
  categoria: 'categoria'
} as const

export type CategoriaScalarFieldEnum = (typeof CategoriaScalarFieldEnum)[keyof typeof CategoriaScalarFieldEnum]


export const CategoriesScalarFieldEnum = {
  category_id: 'category_id',
  category_name: 'category_name',
  params: 'params',
  is_active: 'is_active',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


export const CommentScalarFieldEnum = {
  CommentId: 'CommentId',
  Comment: 'Comment',
  ResponseId: 'ResponseId',
  UserId: 'UserId',
  UserName: 'UserName',
  Status: 'Status',
  CreatedAt: 'CreatedAt',
  UpdatedAt: 'UpdatedAt'
} as const

export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


export const ConfigsScalarFieldEnum = {
  config_id: 'config_id',
  params: 'params',
  is_active: 'is_active',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type ConfigsScalarFieldEnum = (typeof ConfigsScalarFieldEnum)[keyof typeof ConfigsScalarFieldEnum]


export const DepartamentoScalarFieldEnum = {
  id: 'id',
  departamento: 'departamento'
} as const

export type DepartamentoScalarFieldEnum = (typeof DepartamentoScalarFieldEnum)[keyof typeof DepartamentoScalarFieldEnum]


export const DepartmentsScalarFieldEnum = {
  department_id: 'department_id',
  department_name: 'department_name',
  is_active: 'is_active',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type DepartmentsScalarFieldEnum = (typeof DepartmentsScalarFieldEnum)[keyof typeof DepartmentsScalarFieldEnum]


export const IssIndicadoresMacroeconomicosScalarFieldEnum = {
  iss_absorcionhorizontal: 'iss_absorcionhorizontal',
  iss_absorcionindustrial: 'iss_absorcionindustrial',
  iss_absorcionoficinas: 'iss_absorcionoficinas',
  iss_absorcionvertical: 'iss_absorcionvertical',
  iss_ActividadesInmobiliariasEmpresarialyAlqui: 'iss_ActividadesInmobiliariasEmpresarialyAlqui',
  iss_actividadservcomunitariosocialprofesional: 'iss_actividadservcomunitariosocialprofesional',
  iss_administracionpublicaydefensaseguridadsoc: 'iss_administracionpublicaydefensaseguridadsoc',
  iss_agriculturaganaderiacazaysilvicultura: 'iss_agriculturaganaderiacazaysilvicultura',
  iss_a_o: 'iss_a_o',
  iss_bancochn: 'iss_bancochn',
  iss_bancodeamericacentral: 'iss_bancodeamericacentral',
  iss_bancodeantigua: 'iss_bancodeantigua',
  iss_bancodelagro: 'iss_bancodelagro',
  iss_bancoindustrial: 'iss_bancoindustrial',
  iss_bancoinmobiliario: 'iss_bancoinmobiliario',
  iss_bancointernacional: 'iss_bancointernacional',
  iss_banrural: 'iss_banrural',
  iss_bantrab: 'iss_bantrab',
  iss_comercioalpormayorymenor: 'iss_comercioalpormayorymenor',
  iss_consideralaeconomiadelpaismejorno: 'iss_consideralaeconomiadelpaismejorno',
  iss_consideralaeconomiadelpaismejorsi: 'iss_consideralaeconomiadelpaismejorsi',
  iss_construccion: 'iss_construccion',
  iss_Indicadoresguid: 'iss_Indicadoresguid',
  iss_construccionmorosidaden: 'iss_construccionmorosidaden',
  iss_construccionmorosidadenq: 'iss_construccionmorosidadenq',
  iss_construccionsaldosen: 'iss_construccionsaldosen',
  iss_construccionsaldosenq: 'iss_construccionsaldosenq',
  iss_construcciontasadeinteresen: 'iss_construcciontasadeinteresen',
  iss_construcciontasadeinteresenq: 'iss_construcciontasadeinteresenq',
  iss_coyunturaactualparainversionesmalmomento: 'iss_coyunturaactualparainversionesmalmomento',
  iss_coyunturaactualpararealizarinverionessi: 'iss_coyunturaactualpararealizarinverionessi',
  iss_coyunturaactualpararealizarinversionesno: 'iss_coyunturaactualpararealizarinversionesno',
  iss_desocupacionhorizontal: 'iss_desocupacionhorizontal',
  iss_desocupacionindustrial: 'iss_desocupacionindustrial',
  iss_desocupacionoficinas: 'iss_desocupacionoficinas',
  iss_desocupacionvertical: 'iss_desocupacionvertical',
  iss_diferenciamensualdeanoactualvrsanoanterio: 'iss_diferenciamensualdeanoactualvrsanoanterio',
  iss_empleadosdedependenciaestudiantesyjubilad: 'iss_empleadosdedependenciaestudiantesyjubilad',
  iss_ensenanza: 'iss_ensenanza',
  statecode: 'statecode',
  iss_evolucionclimadenegociosempeorara: 'iss_evolucionclimadenegociosempeorara',
  iss_evolucionclimadenegociospermaneceigual: 'iss_evolucionclimadenegociospermaneceigual',
  iss_evoluciondelclimadelosnegociosmejorara: 'iss_evoluciondelclimadelosnegociosmejorara',
  iss_expectativasdeinflacion: 'iss_expectativasdeinflacion',
  iss_explotaciondeminasycanteras: 'iss_explotaciondeminasycanteras',
  iss_ficohsa: 'iss_ficohsa',
  iss_gtcontinental: 'iss_gtcontinental',
  iss_hipotecarioparaviviendamorosidaden: 'iss_hipotecarioparaviviendamorosidaden',
  iss_hipotecarioparaviviendamorosidadenq: 'iss_hipotecarioparaviviendamorosidadenq',
  iss_hipotecarioparaviviendasaldosen: 'iss_hipotecarioparaviviendasaldosen',
  iss_hipotecarioparaviviendasaldosenq: 'iss_hipotecarioparaviviendasaldosenq',
  iss_hipotecarioparaviviendatasadeintere: 'iss_hipotecarioparaviviendatasadeintere',
  iss_hipotecarioparaviviendatasadeinteres: 'iss_hipotecarioparaviviendatasadeinteres',
  iss_horizontalacabados: 'iss_horizontalacabados',
  iss_horizontalenconstruccion: 'iss_horizontalenconstruccion',
  iss_horizontalenplanos: 'iss_horizontalenplanos',
  iss_horizontalentregadosenventa: 'iss_horizontalentregadosenventa',
  iss_horizontalmovimientodetierras: 'iss_horizontalmovimientodetierras',
  iss_horizontalobragris: 'iss_horizontalobragris',
  iss_hotelesyrestaurantes: 'iss_hotelesyrestaurantes',
  iss_imaeoriginal: 'iss_imaeoriginal',
  iss_imaetendenciadelciclo: 'iss_imaetendenciadelciclo',
  iss_industrialacabados: 'iss_industrialacabados',
  iss_industrialenconstruccion: 'iss_industrialenconstruccion',
  iss_industriaenplanos: 'iss_industriaenplanos',
  iss_industrialentregadosenventa: 'iss_industrialentregadosenventa',
  iss_industrialmovimientodetierras: 'iss_industrialmovimientodetierras',
  iss_industrialobragris: 'iss_industrialobragris',
  iss_industrias: 'iss_industrias',
  iss_ingresoporcapitalanual: 'iss_ingresoporcapitalanual',
  iss_ingresoporcapitalmensual: 'iss_ingresoporcapitalmensual',
  iss_intermediacionfinanciera: 'iss_intermediacionfinanciera',
  iss_invsa: 'iss_invsa',
  iss_mejoraralaeconomiadelpaisen6mesesno: 'iss_mejoraralaeconomiadelpaisen6mesesno',
  iss_mejoraralaeconomiadelpaisen6mesessi: 'iss_mejoraralaeconomiadelpaisen6mesessi',
  iss_mes: 'iss_mes',
  iss_meses: 'iss_meses',
  iss_oficinasacabados: 'iss_oficinasacabados',
  iss_oficinasenconstruccion: 'iss_oficinasenconstruccion',
  iss_oficinasenplanos: 'iss_oficinasenplanos',
  iss_oficinasentregadosenventa: 'iss_oficinasentregadosenventa',
  iss_oficinasmovimientodetierras: 'iss_oficinasmovimientodetierras',
  iss_oficinasobragris: 'iss_oficinasobragris',
  iss_organizacionesyorganosextraterritoriales: 'iss_organizacionesyorganosextraterritoriales',
  iss_otrasactividades: 'iss_otrasactividades',
  iss_pibanualen: 'iss_pibanualen',
  iss_pibanualenq: 'iss_pibanualenq',
  iss_poblacion: 'iss_poblacion',
  iss_produccionhorizontal: 'iss_produccionhorizontal',
  iss_produccionindustrial: 'iss_produccionindustrial',
  iss_produccionoficinas: 'iss_produccionoficinas',
  iss_produccionvertical: 'iss_produccionvertical',
  iss_promerica: 'iss_promerica',
  iss_remesasen: 'iss_remesasen',
  iss_remesasenq: 'iss_remesasenq',
  iss_serviciossocialesydesalud: 'iss_serviciossocialesydesalud',
  iss_suministrodeelectricidadgasyagua: 'iss_suministrodeelectricidadgasyagua',
  iss_tasadecreditoshipotecarios: 'iss_tasadecreditoshipotecarios',
  iss_transportealmacenamientoycomunicaciones: 'iss_transportealmacenamientoycomunicaciones',
  iss_trimestre: 'iss_trimestre',
  iss_variacionporcentualipc: 'iss_variacionporcentualipc',
  iss_variacionporcentualpib: 'iss_variacionporcentualpib',
  iss_verticalacabados: 'iss_verticalacabados',
  iss_verticalenconstruccion: 'iss_verticalenconstruccion',
  iss_verticalenplanos: 'iss_verticalenplanos',
  iss_verticalentregadosenventa: 'iss_verticalentregadosenventa',
  iss_verticalmovimientodetierras: 'iss_verticalmovimientodetierras',
  iss_verticalobragris: 'iss_verticalobragris',
  iss_vivibanco: 'iss_vivibanco'
} as const

export type IssIndicadoresMacroeconomicosScalarFieldEnum = (typeof IssIndicadoresMacroeconomicosScalarFieldEnum)[keyof typeof IssIndicadoresMacroeconomicosScalarFieldEnum]


export const IssRecoleccionProyectosScalarFieldEnum = {
  iss_ProyectoPeriodGuid: 'iss_ProyectoPeriodGuid',
  iss_ApartamentooCasaModelo: 'iss_ApartamentooCasaModelo',
  iss_CantidaddeNiveles: 'iss_CantidaddeNiveles',
  iss_CantidaddeParqueosdeUnidades2: 'iss_CantidaddeParqueosdeUnidades2',
  iss_CantidaddeUnidades2: 'iss_CantidaddeUnidades2',
  iss_CantidadTotaldeParqueos: 'iss_CantidadTotaldeParqueos',
  iss_EngancheFraccionado: 'iss_EngancheFraccionado',
  iss_FechadeEntrega: 'iss_FechadeEntrega',
  iss_FechadeIniciodelProyecto: 'iss_FechadeIniciodelProyecto',
  iss_FechadeRecoleccin: 'iss_FechadeRecoleccin',
  iss_M2Totales2: 'iss_M2Totales2',
  iss_ModalidadFHA: 'iss_ModalidadFHA',
  iss_NombredelProyecto: 'iss_NombredelProyecto',
  iss_Periodo: 'iss_Periodo',
  iss_ProyectoGuid: 'iss_ProyectoGuid',
  iss_parqueodisponibleparaventadecondomenes: 'iss_parqueodisponibleparaventadecondomenes',
  iss_parqueoexclusivodevisitas: 'iss_parqueoexclusivodevisitas',
  iss_parqueopararentadecodomenes: 'iss_parqueopararentadecodomenes',
  iss_plazodeenganchefraccionado: 'iss_plazodeenganchefraccionado',
  statuscode: 'statuscode',
  iss_revitalizado: 'iss_revitalizado',
  iss_showroom: 'iss_showroom',
  iss_tipodemarketscan: 'iss_tipodemarketscan',
  iss_torreofase: 'iss_torreofase',
  iss_uso: 'iss_uso',
  iss_clasificacionporzona: 'iss_clasificacionporzona',
  iss_pais: 'iss_pais',
  iss_barrio: 'iss_barrio',
  iss_barriocr: 'iss_barriocr',
  iss_cantidaddeviviendas: 'iss_cantidaddeviviendas',
  iss_canton: 'iss_canton',
  iss_cantoncr: 'iss_cantoncr',
  iss_categoria: 'iss_categoria',
  iss_categoriaoriginal: 'iss_categoriaoriginal',
  iss_colonia: 'iss_colonia',
  iss_departamento: 'iss_departamento',
  iss_distrito: 'iss_distrito',
  iss_latitud: 'iss_latitud',
  iss_longitud: 'iss_longitud',
  iss_mercadoprimario: 'iss_mercadoprimario',
  iss_mercadosecundario: 'iss_mercadosecundario',
  iss_municipio: 'iss_municipio',
  iss_parqueopararentadecondomenes: 'iss_parqueopararentadecondomenes',
  iss_provinciacr: 'iss_provinciacr',
  iss_subcategoria: 'iss_subcategoria',
  iss_subzona: 'iss_subzona',
  iss_tipoderevitalizado: 'iss_tipoderevitalizado',
  iss_totaldeparqueos: 'iss_totaldeparqueos',
  iss_vendido: 'iss_vendido',
  iss_mercadosecundarioincompleto: 'iss_mercadosecundarioincompleto',
  iss_parqueoparacontenedores: 'iss_parqueoparacontenedores',
  iss_cantidaddeparqueosparacontenedores: 'iss_cantidaddeparqueosparacontenedores',
  iss_absorcionunitaria: 'iss_absorcionunitaria',
  iss_absorcionporm2: 'iss_absorcionporm2',
  iss_zona: 'iss_zona',
  iss_CantidaddeParqueosdeUnidadesSecundario: 'iss_CantidaddeParqueosdeUnidadesSecundario',
  iss_m2totalessecundario: 'iss_m2totalessecundario',
  iss_desarrollador: 'iss_desarrollador',
  iss_ConstructoraMovimientoDeTierras: 'iss_ConstructoraMovimientoDeTierras',
  iss_ConstructoraObraGris: 'iss_ConstructoraObraGris',
  iss_ConstructoraAcabados: 'iss_ConstructoraAcabados',
  iss_Constructora4: 'iss_Constructora4',
  iss_Constructora5: 'iss_Constructora5'
} as const

export type IssRecoleccionProyectosScalarFieldEnum = (typeof IssRecoleccionProyectosScalarFieldEnum)[keyof typeof IssRecoleccionProyectosScalarFieldEnum]


export const MunicipalitiesScalarFieldEnum = {
  municipality_id: 'municipality_id',
  municipality_name: 'municipality_name',
  department_id: 'department_id',
  is_active: 'is_active',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type MunicipalitiesScalarFieldEnum = (typeof MunicipalitiesScalarFieldEnum)[keyof typeof MunicipalitiesScalarFieldEnum]


export const MunicipioScalarFieldEnum = {
  id: 'id',
  municipio: 'municipio',
  Departamento_id: 'Departamento_id'
} as const

export type MunicipioScalarFieldEnum = (typeof MunicipioScalarFieldEnum)[keyof typeof MunicipioScalarFieldEnum]


export const ProjectsScalarFieldEnum = {
  project_id: 'project_id',
  project_name: 'project_name',
  project_uuid: 'project_uuid',
  project_sold_out: 'project_sold_out',
  project_primary_market: 'project_primary_market',
  project_longitude: 'project_longitude',
  project_latitude: 'project_latitude',
  project_last_recolection: 'project_last_recolection',
  status_id: 'status_id',
  subcategory_id: 'subcategory_id',
  applications_id: 'applications_id',
  zone_id: 'zone_id',
  is_active: 'is_active',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type ProjectsScalarFieldEnum = (typeof ProjectsScalarFieldEnum)[keyof typeof ProjectsScalarFieldEnum]


export const ProjectsVersionsScalarFieldEnum = {
  project_version_uuid: 'project_version_uuid',
  project_id: 'project_id',
  project_name: 'project_name',
  project_uuid: 'project_uuid',
  project_sold_out: 'project_sold_out',
  project_primary_market: 'project_primary_market',
  status_id: 'status_id',
  subcategory_id: 'subcategory_id',
  applications_id: 'applications_id',
  zone_id: 'zone_id',
  is_active: 'is_active',
  last_recolection_date: 'last_recolection_date',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type ProjectsVersionsScalarFieldEnum = (typeof ProjectsVersionsScalarFieldEnum)[keyof typeof ProjectsVersionsScalarFieldEnum]


export const ProyectStatusScalarFieldEnum = {
  id: 'id',
  name: 'name'
} as const

export type ProyectStatusScalarFieldEnum = (typeof ProyectStatusScalarFieldEnum)[keyof typeof ProyectStatusScalarFieldEnum]


export const ProyectoScalarFieldEnum = {
  Id: 'Id',
  Name: 'Name',
  Uuid: 'Uuid',
  Vendido: 'Vendido',
  MercadoPrimario: 'MercadoPrimario',
  SubCategoriaId: 'SubCategoriaId',
  UsoId: 'UsoId',
  StatusId: 'StatusId',
  ZonaId: 'ZonaId',
  LastRecolectionDate: 'LastRecolectionDate',
  Country: 'Country'
} as const

export type ProyectoScalarFieldEnum = (typeof ProyectoScalarFieldEnum)[keyof typeof ProyectoScalarFieldEnum]


export const ResponseScalarFieldEnum = {
  ResponseId: 'ResponseId',
  Status: 'Status',
  Environment: 'Environment',
  CreatedAt: 'CreatedAt',
  UpdatedAt: 'UpdatedAt'
} as const

export type ResponseScalarFieldEnum = (typeof ResponseScalarFieldEnum)[keyof typeof ResponseScalarFieldEnum]


export const StatusesScalarFieldEnum = {
  status_id: 'status_id',
  status_name: 'status_name',
  is_active: 'is_active',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type StatusesScalarFieldEnum = (typeof StatusesScalarFieldEnum)[keyof typeof StatusesScalarFieldEnum]


export const SubCategoriaScalarFieldEnum = {
  id: 'id',
  subcategoria: 'subcategoria',
  Categoria_id: 'Categoria_id'
} as const

export type SubCategoriaScalarFieldEnum = (typeof SubCategoriaScalarFieldEnum)[keyof typeof SubCategoriaScalarFieldEnum]


export const SubcategoriesScalarFieldEnum = {
  subcategory_id: 'subcategory_id',
  subcategory_name: 'subcategory_name',
  category_id: 'category_id',
  is_active: 'is_active',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type SubcategoriesScalarFieldEnum = (typeof SubcategoriesScalarFieldEnum)[keyof typeof SubcategoriesScalarFieldEnum]


export const UnidadesScalarFieldEnum = {
  Id: 'Id',
  Name: 'Name',
  CantidadDormitorios: 'CantidadDormitorios',
  CantidadSanitarios: 'CantidadSanitarios',
  CantidadParqueos: 'CantidadParqueos',
  ValorPropiedad: 'ValorPropiedad',
  PrecioRentaTotal: 'PrecioRentaTotal',
  PrecioMantenimientoTotal: 'PrecioMantenimientoTotal',
  SuperficieTotal: 'SuperficieTotal',
  LastRecolectionDate: 'LastRecolectionDate',
  ProyectoId: 'ProyectoId',
  Country: 'Country'
} as const

export type UnidadesScalarFieldEnum = (typeof UnidadesScalarFieldEnum)[keyof typeof UnidadesScalarFieldEnum]


export const UnitsScalarFieldEnum = {
  unit_id: 'unit_id',
  unit_name: 'unit_name',
  unit_bedrooms: 'unit_bedrooms',
  unit_parking_lots: 'unit_parking_lots',
  unit_toilets: 'unit_toilets',
  unit_maintenance_price: 'unit_maintenance_price',
  unit_rent_price: 'unit_rent_price',
  unit_total_area: 'unit_total_area',
  unit_property_value: 'unit_property_value',
  unit_last_recolection_date: 'unit_last_recolection_date',
  project_id: 'project_id',
  is_active: 'is_active',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type UnitsScalarFieldEnum = (typeof UnitsScalarFieldEnum)[keyof typeof UnitsScalarFieldEnum]


export const UnitsVersionsScalarFieldEnum = {
  unit_version_uuid: 'unit_version_uuid',
  unit_id: 'unit_id',
  unit_name: 'unit_name',
  unit_bedrooms: 'unit_bedrooms',
  unit_parking_lots: 'unit_parking_lots',
  unit_toilets: 'unit_toilets',
  unit_maintenance_price: 'unit_maintenance_price',
  unit_rent_price: 'unit_rent_price',
  unit_total_area: 'unit_total_area',
  unit_property_value: 'unit_property_value',
  unit_last_recolection_date: 'unit_last_recolection_date',
  project_id: 'project_id',
  project_version_uuid: 'project_version_uuid',
  is_active: 'is_active',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type UnitsVersionsScalarFieldEnum = (typeof UnitsVersionsScalarFieldEnum)[keyof typeof UnitsVersionsScalarFieldEnum]


export const UsoScalarFieldEnum = {
  id: 'id',
  uso: 'uso'
} as const

export type UsoScalarFieldEnum = (typeof UsoScalarFieldEnum)[keyof typeof UsoScalarFieldEnum]


export const ZonaScalarFieldEnum = {
  id: 'id',
  zona: 'zona',
  Municipio_id: 'Municipio_id'
} as const

export type ZonaScalarFieldEnum = (typeof ZonaScalarFieldEnum)[keyof typeof ZonaScalarFieldEnum]


export const ZonesScalarFieldEnum = {
  zone_id: 'zone_id',
  zone_name: 'zone_name',
  municipality_id: 'municipality_id',
  is_active: 'is_active',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type ZonesScalarFieldEnum = (typeof ZonesScalarFieldEnum)[keyof typeof ZonesScalarFieldEnum]


export const Housing_amenitiesScalarFieldEnum = {
  id: 'id',
  proyecto: 'proyecto',
  cod_proyecto: 'cod_proyecto',
  piscina_infantil: 'piscina_infantil',
  piscina_interior: 'piscina_interior',
  piscina_exterior: 'piscina_exterior',
  lap_pool: 'lap_pool',
  area_social_cerrada: 'area_social_cerrada',
  area_social_abierta: 'area_social_abierta',
  area_social_terraza: 'area_social_terraza',
  casa_club: 'casa_club',
  tendedero_lavanderia_terraza: 'tendedero_lavanderia_terraza',
  area_bbq: 'area_bbq',
  area_ninos: 'area_ninos',
  gimnasio: 'gimnasio',
  baby_gym_day_care: 'baby_gym_day_care',
  area_verde_primer_nivel: 'area_verde_primer_nivel',
  sky_park: 'sky_park',
  bar: 'bar',
  coworking: 'coworking',
  business_center: 'business_center',
  cancha_polideportiva: 'cancha_polideportiva',
  cancha_tenis: 'cancha_tenis',
  cancha_basketball: 'cancha_basketball',
  cancha_futball: 'cancha_futball',
  cancha_squash: 'cancha_squash',
  wifi: 'wifi',
  spa: 'spa',
  sauna: 'sauna',
  caminamientos_jogging_track: 'caminamientos_jogging_track',
  pet_friendly: 'pet_friendly',
  fogatero: 'fogatero',
  area_comercial: 'area_comercial',
  cinema: 'cinema',
  salon_de_cocina: 'salon_de_cocina',
  zen_garden: 'zen_garden',
  espacio_para_ejercitarse: 'espacio_para_ejercitarse',
  camping_park: 'camping_park',
  lobby: 'lobby',
  deck: 'deck',
  jacuzzi: 'jacuzzi',
  game_room: 'game_room',
  lavanderia: 'lavanderia',
  restaurante: 'restaurante',
  golf: 'golf',
  ecuestre: 'ecuestre',
  mini_golf: 'mini_golf',
  laguna: 'laguna',
  created_at: 'created_at'
} as const

export type Housing_amenitiesScalarFieldEnum = (typeof Housing_amenitiesScalarFieldEnum)[keyof typeof Housing_amenitiesScalarFieldEnum]


export const Housing_servicesScalarFieldEnum = {
  id: 'id',
  proyecto: 'proyecto',
  cod_proyecto: 'cod_proyecto',
  aceras: 'aceras',
  agua_potable: 'agua_potable',
  alcantarillado: 'alcantarillado',
  alumbrado_publico: 'alumbrado_publico',
  elevadores: 'elevadores',
  garita_seguridad: 'garita_seguridad',
  planta_de_luz: 'planta_de_luz',
  planta_de_tratamiento: 'planta_de_tratamiento',
  pozo_propio: 'pozo_propio',
  created_at: 'created_at'
} as const

export type Housing_servicesScalarFieldEnum = (typeof Housing_servicesScalarFieldEnum)[keyof typeof Housing_servicesScalarFieldEnum]


export const Housing_unitsScalarFieldEnum = {
  id: 'id',
  proyecto: 'proyecto',
  periodo: 'periodo',
  frente_m2: 'frente_m2',
  frente_v2: 'frente_v2',
  fondo_m2: 'fondo_m2',
  fondo_v2: 'fondo_v2',
  m2_terreno: 'm2_terreno',
  v2_terreno: 'v2_terreno',
  topografia: 'topografia',
  num_unidad: 'num_unidad',
  modelo: 'modelo',
  torre_fase: 'torre_fase',
  unidad: 'unidad',
  tama_o_unidad: 'tama_o_unidad',
  tama_o_balcon_terraza: 'tama_o_balcon_terraza',
  cant_dormitorios: 'cant_dormitorios',
  cant_sanitarios: 'cant_sanitarios',
  parqueo: 'parqueo',
  tipo_parqueo: 'tipo_parqueo',
  cant_parqueos: 'cant_parqueos',
  parqueo_moto: 'parqueo_moto',
  tama_o_parqueo: 'tama_o_parqueo',
  tama_o_total: 'tama_o_total',
  construccion_habitable_m2: 'construccion_habitable_m2',
  construccion_habitable_v2: 'construccion_habitable_v2',
  uso: 'uso',
  precio_total_usd: 'precio_total_usd',
  precio_total_qtz: 'precio_total_qtz',
  precio_sin_iva_usd: 'precio_sin_iva_usd',
  precio_sin_iva_qtz: 'precio_sin_iva_qtz',
  precio_m2_usd: 'precio_m2_usd',
  precio_v2_usd: 'precio_v2_usd',
  precio_renta_usd: 'precio_renta_usd',
  precio_renta_qtz: 'precio_renta_qtz',
  precio_renta_sin_iva_usd: 'precio_renta_sin_iva_usd',
  precio_renta_sin_iva_qtz: 'precio_renta_sin_iva_qtz',
  precio_renta_m2_sin_iva_usd: 'precio_renta_m2_sin_iva_usd',
  precio_renta_m2_sin_iva_qtz: 'precio_renta_m2_sin_iva_qtz',
  disponibilidad: 'disponibilidad',
  precio_mantenimiento_total: 'precio_mantenimiento_total',
  precio_mantenimiento_m2: 'precio_mantenimiento_m2',
  precio_mantenimiento_v2: 'precio_mantenimiento_v2',
  categoria: 'categoria',
  hora_recoleccion: 'hora_recoleccion',
  nse: 'nse',
  cuota: 'cuota',
  ingresos: 'ingresos',
  absorcion_unitaria: 'absorcion_unitaria',
  absorcion_m2: 'absorcion_m2',
  cod_texto: 'cod_texto',
  cod_proyecto: 'cod_proyecto',
  created_at: 'created_at'
} as const

export type Housing_unitsScalarFieldEnum = (typeof Housing_unitsScalarFieldEnum)[keyof typeof Housing_unitsScalarFieldEnum]


export const Housing_universeScalarFieldEnum = {
  id: 'id',
  cod_proyecto: 'cod_proyecto',
  fecha_recoleccion: 'fecha_recoleccion',
  proyecto: 'proyecto',
  fase: 'fase',
  torre: 'torre',
  periodo: 'periodo',
  categoria: 'categoria',
  pais: 'pais',
  departamento: 'departamento',
  municipio: 'municipio',
  zona: 'zona',
  subzona: 'subzona',
  desarrollador: 'desarrollador',
  estado: 'estado',
  uso: 'uso',
  fecha_inicio: 'fecha_inicio',
  fecha_entrega: 'fecha_entrega',
  meses_de_comercializacion: 'meses_de_comercializacion',
  latitud: 'latitud',
  longitud: 'longitud',
  fha: 'fha',
  total_unidades: 'total_unidades',
  total_m2: 'total_m2',
  tipo_de_seguridad: 'tipo_de_seguridad',
  muvi: 'muvi',
  unidades_disponibles: 'unidades_disponibles',
  m2_disponibles: 'm2_disponibles',
  precio_promedio: 'precio_promedio',
  tamano_promedio: 'tamano_promedio',
  precio_prom_m2: 'precio_prom_m2',
  cuota_promedio: 'cuota_promedio',
  ingresos_promedio: 'ingresos_promedio',
  nse_proyecto: 'nse_proyecto',
  showroom: 'showroom',
  casa_modelo: 'casa_modelo',
  cantidad_accesos: 'cantidad_accesos',
  mercado: 'mercado',
  precio_parqueo_adicional: 'precio_parqueo_adicional',
  parqueos_visita: 'parqueos_visita',
  parqueos_asignados: 'parqueos_asignados',
  total_parqueos_proyecto: 'total_parqueos_proyecto',
  url_imagen: 'url_imagen',
  mig_number: 'mig_number',
  created_at: 'created_at'
} as const

export type Housing_universeScalarFieldEnum = (typeof Housing_universeScalarFieldEnum)[keyof typeof Housing_universeScalarFieldEnum]


export const Industrial_amenitiesScalarFieldEnum = {
  id: 'id',
  COD: 'COD',
  patio_de_maniobras: 'patio_de_maniobras',
  sala_de_reuniones: 'sala_de_reuniones',
  area_de_coworking: 'area_de_coworking',
  cafeteria: 'cafeteria',
  areas_verdes: 'areas_verdes',
  area_comercial: 'area_comercial',
  gimnasio_al_aire_libre: 'gimnasio_al_aire_libre',
  cancha_deportiva: 'cancha_deportiva',
  parqueo_comun_de_contenedores: 'parqueo_comun_de_contenedores',
  sistema_contra_incendios: 'sistema_contra_incendios',
  area_de_pilotos: 'area_de_pilotos',
  vestibulo_con_ducha: 'vestibulo_con_ducha',
  area_de_descarga_en_garita: 'area_de_descarga_en_garita',
  anden_comun: 'anden_comun',
  area_social: 'area_social',
  helipuerto: 'helipuerto',
  area_de_oficinas: 'area_de_oficinas',
  clinica_medica: 'clinica_medica',
  zona_residencial: 'zona_residencial',
  centros_educativos: 'centros_educativos',
  ciclovias: 'ciclovias',
  vias_peatonal: 'vias_peatonal',
  otros: 'otros',
  created_at: 'created_at'
} as const

export type Industrial_amenitiesScalarFieldEnum = (typeof Industrial_amenitiesScalarFieldEnum)[keyof typeof Industrial_amenitiesScalarFieldEnum]


export const Industrial_unitsScalarFieldEnum = {
  id: 'id',
  COD: 'COD',
  proyecto: 'proyecto',
  periodo: 'periodo',
  no_de_bodega: 'no_de_bodega',
  fase: 'fase',
  sector_cluster: 'sector_cluster',
  categor_a: 'categor_a',
  tamano_de_terreno_m2: 'tamano_de_terreno_m2',
  tamano_de_terreno_v2: 'tamano_de_terreno_v2',
  tamano_bodega_almacenamiento_m2: 'tamano_bodega_almacenamiento_m2',
  tamano_bodega_almacenamiento_v2: 'tamano_bodega_almacenamiento_v2',
  tamano_de_oficina_m2: 'tamano_de_oficina_m2',
  tamano_de_mezzanine_m2: 'tamano_de_mezzanine_m2',
  area_carga_m2: 'area_carga_m2',
  ancho_1_m2: 'ancho_1_m2',
  fondo_1_m2: 'fondo_1_m2',
  fondo_2_m2: 'fondo_2_m2',
  alto_m2: 'alto_m2',
  cantidad_banos: 'cantidad_banos',
  parqueo_de_vehiculo: 'parqueo_de_vehiculo',
  cantidad_de_parqueos: 'cantidad_de_parqueos',
  precio_por_parqueo_adicional_usd: 'precio_por_parqueo_adicional_usd',
  tamano_de_parqueos_m2: 'tamano_de_parqueos_m2',
  tamano_total_m2: 'tamano_total_m2',
  tamano_sin_parqueo_m2: 'tamano_sin_parqueo_m2',
  uso: 'uso',
  precio_total_usd: 'precio_total_usd',
  precio_total_qzl: 'precio_total_qzl',
  precio_sin_iva_usd: 'precio_sin_iva_usd',
  precio_sin_iva_qtz: 'precio_sin_iva_qtz',
  precio_m2_usd: 'precio_m2_usd',
  precio_v2_usd: 'precio_v2_usd',
  precio_renta_usd: 'precio_renta_usd',
  precio_renta_qtz: 'precio_renta_qtz',
  renta_sin_iva_usd: 'renta_sin_iva_usd',
  renta_sin_iva_qtz: 'renta_sin_iva_qtz',
  renta_m2_usd: 'renta_m2_usd',
  renta_v2_usd: 'renta_v2_usd',
  Disponible: 'Disponible',
  precio_mantenimiento: 'precio_mantenimiento',
  mantenimiento_m2: 'mantenimiento_m2',
  mantenimiento_v2: 'mantenimiento_v2',
  fecha_recoleccion: 'fecha_recoleccion',
  hora_recoleccion: 'hora_recoleccion',
  fecha_inicio: 'fecha_inicio',
  clasificacion: 'clasificacion',
  absorcion_unitaria: 'absorcion_unitaria',
  absorcion_m2: 'absorcion_m2',
  absorcion_v2: 'absorcion_v2',
  created_at: 'created_at'
} as const

export type Industrial_unitsScalarFieldEnum = (typeof Industrial_unitsScalarFieldEnum)[keyof typeof Industrial_unitsScalarFieldEnum]


export const Industrial_universeScalarFieldEnum = {
  id: 'id',
  COD: 'COD',
  proyecto: 'proyecto',
  fecha_recoleccion: 'fecha_recoleccion',
  fase: 'fase',
  sector_cluster: 'sector_cluster',
  periodo: 'periodo',
  categoria: 'categoria',
  desarrollador: 'desarrollador',
  pais: 'pais',
  departamento: 'departamento',
  municipio: 'municipio',
  zona: 'zona',
  estado: 'estado',
  uso: 'uso',
  enfoque: 'enfoque',
  compartido_exclusivo: 'compartido_exclusivo',
  fecha_inicio: 'fecha_inicio',
  fecha_entrega: 'fecha_entrega',
  latitud: 'latitud',
  longitud: 'longitud',
  enganche: 'enganche',
  enganche_fraccionado: 'enganche_fraccionado',
  meses_de_comercializacion: 'meses_de_comercializacion',
  total_m2: 'total_m2',
  total_unidades: 'total_unidades',
  total_m2_disponibles: 'total_m2_disponibles',
  total_unidades_disponibles: 'total_unidades_disponibles',
  parqueos_asignados: 'parqueos_asignados',
  parqueos_de_visita: 'parqueos_de_visita',
  total_parqueos_proyecto: 'total_parqueos_proyecto',
  lote_migracion: 'lote_migracion',
  created_at: 'created_at'
} as const

export type Industrial_universeScalarFieldEnum = (typeof Industrial_universeScalarFieldEnum)[keyof typeof Industrial_universeScalarFieldEnum]


export const IssAmenidadesScalarFieldEnum = {
  Guid_Proyecto_Amenidades: 'Guid_Proyecto_Amenidades',
  Guid_Proyecto: 'Guid_Proyecto',
  iss_Proyecto: 'iss_Proyecto',
  iss_Amenidad: 'iss_Amenidad'
} as const

export type IssAmenidadesScalarFieldEnum = (typeof IssAmenidadesScalarFieldEnum)[keyof typeof IssAmenidadesScalarFieldEnum]


export const Office_amenitiesScalarFieldEnum = {
  id: 'id',
  proyecto: 'proyecto',
  cod_proyecto: 'cod_proyecto',
  lobby: 'lobby',
  restaurante_foodcourt: 'restaurante_foodcourt',
  area_comedores_cafeteria: 'area_comedores_cafeteria',
  spa: 'spa',
  terraza: 'terraza',
  areas_verdes: 'areas_verdes',
  area_comercial: 'area_comercial',
  co_working: 'co_working',
  business_center: 'business_center',
  gym: 'gym',
  game_room: 'game_room',
  area_social_cerrada: 'area_social_cerrada',
  area_descanso: 'area_descanso',
  area_social_abierta: 'area_social_abierta',
  salones_para_eventos: 'salones_para_eventos',
  helipuerto: 'helipuerto',
  kids_playground: 'kids_playground',
  beach_club: 'beach_club',
  plaza_financiera: 'plaza_financiera',
  area_paqueteria: 'area_paqueteria',
  creation_date: 'creation_date'
} as const

export type Office_amenitiesScalarFieldEnum = (typeof Office_amenitiesScalarFieldEnum)[keyof typeof Office_amenitiesScalarFieldEnum]


export const Office_unitsScalarFieldEnum = {
  id: 'id',
  proyecto: 'proyecto',
  cod_proyecto: 'cod_proyecto',
  periodo: 'periodo',
  no_unidad: 'no_unidad',
  torre: 'torre',
  unidad: 'unidad',
  tamano_de_unidad_m2: 'tamano_de_unidad_m2',
  tamano_de_balcon_o_terraza_m2: 'tamano_de_balcon_o_terraza_m2',
  parqueo_de_vehiculo: 'parqueo_de_vehiculo',
  cantidad_de_parqueos_unidad: 'cantidad_de_parqueos_unidad',
  parqueos_para_venta: 'parqueos_para_venta',
  tamano_parqueo_m2: 'tamano_parqueo_m2',
  construccion_total_m2: 'construccion_total_m2',
  construccion_habitable_m2: 'construccion_habitable_m2',
  uso: 'uso',
  precio_total_usd: 'precio_total_usd',
  precio_total_qtz: 'precio_total_qtz',
  precio_sin_iva_usd: 'precio_sin_iva_usd',
  precio_sin_iva_qtz: 'precio_sin_iva_qtz',
  precio_m2_usd: 'precio_m2_usd',
  precio_renta_usd: 'precio_renta_usd',
  precio_renta_qtz: 'precio_renta_qtz',
  renta_sin_iva_usd: 'renta_sin_iva_usd',
  renta_sin_iva_qtz: 'renta_sin_iva_qtz',
  renta_m2_usd: 'renta_m2_usd',
  disponibilidad: 'disponibilidad',
  precio_mantenimiento: 'precio_mantenimiento',
  mantenimiento_m2: 'mantenimiento_m2',
  cantidad_empleados: 'cantidad_empleados',
  fecha_recoleccion: 'fecha_recoleccion',
  hora_recoleccion: 'hora_recoleccion',
  fecha_inicio: 'fecha_inicio',
  m2_sin_parqueo_usd: 'm2_sin_parqueo_usd',
  valor_propiedad_sin_parqueo_usd: 'valor_propiedad_sin_parqueo_usd',
  clasificacion_oficina: 'clasificacion_oficina',
  clasificacion_general_por_tama_o: 'clasificacion_general_por_tama_o',
  leyenda_cantidad_empleados: 'leyenda_cantidad_empleados',
  leyenda_cantidad_m2: 'leyenda_cantidad_m2',
  leyenda_tama_o_cantidad_empleados: 'leyenda_tama_o_cantidad_empleados',
  leyenda_tama_o_m2: 'leyenda_tama_o_m2',
  absorcion_unitaria: 'absorcion_unitaria',
  absorcion_m2: 'absorcion_m2',
  creation_date: 'creation_date'
} as const

export type Office_unitsScalarFieldEnum = (typeof Office_unitsScalarFieldEnum)[keyof typeof Office_unitsScalarFieldEnum]


export const Office_universeScalarFieldEnum = {
  id: 'id',
  cod_proyecto: 'cod_proyecto',
  fecha_recoleccion: 'fecha_recoleccion',
  proyecto: 'proyecto',
  periodo: 'periodo',
  enfoque_principal: 'enfoque_principal',
  enfoque_secundario: 'enfoque_secundario',
  desarrollador: 'desarrollador',
  pais: 'pais',
  zona: 'zona',
  estado: 'estado',
  fecha_inicio: 'fecha_inicio',
  fecha_entrega: 'fecha_entrega',
  meses_de_comercializacion: 'meses_de_comercializacion',
  latitud: 'latitud',
  longitud: 'longitud',
  uso: 'uso',
  precio_parqueo: 'precio_parqueo',
  parqueos_asignados: 'parqueos_asignados',
  parqueos_para_venta: 'parqueos_para_venta',
  parqueos_visitas: 'parqueos_visitas',
  total_parqueos: 'total_parqueos',
  total_m2: 'total_m2',
  total_unidades: 'total_unidades',
  total_m2_disponibles: 'total_m2_disponibles',
  total_unidades_disponibles: 'total_unidades_disponibles',
  enganche: 'enganche',
  enganche_fraccionado: 'enganche_fraccionado',
  lote_migracion: 'lote_migracion',
  creation_date: 'creation_date'
} as const

export type Office_universeScalarFieldEnum = (typeof Office_universeScalarFieldEnum)[keyof typeof Office_universeScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const ApplicationsOrderByRelevanceFieldEnum = {
  applications_name: 'applications_name'
} as const

export type ApplicationsOrderByRelevanceFieldEnum = (typeof ApplicationsOrderByRelevanceFieldEnum)[keyof typeof ApplicationsOrderByRelevanceFieldEnum]


export const CategoriaOrderByRelevanceFieldEnum = {
  categoria: 'categoria'
} as const

export type CategoriaOrderByRelevanceFieldEnum = (typeof CategoriaOrderByRelevanceFieldEnum)[keyof typeof CategoriaOrderByRelevanceFieldEnum]


export const CategoriesOrderByRelevanceFieldEnum = {
  category_name: 'category_name'
} as const

export type CategoriesOrderByRelevanceFieldEnum = (typeof CategoriesOrderByRelevanceFieldEnum)[keyof typeof CategoriesOrderByRelevanceFieldEnum]


export const CommentOrderByRelevanceFieldEnum = {
  CommentId: 'CommentId',
  Comment: 'Comment',
  ResponseId: 'ResponseId',
  UserId: 'UserId',
  UserName: 'UserName'
} as const

export type CommentOrderByRelevanceFieldEnum = (typeof CommentOrderByRelevanceFieldEnum)[keyof typeof CommentOrderByRelevanceFieldEnum]


export const DepartamentoOrderByRelevanceFieldEnum = {
  departamento: 'departamento'
} as const

export type DepartamentoOrderByRelevanceFieldEnum = (typeof DepartamentoOrderByRelevanceFieldEnum)[keyof typeof DepartamentoOrderByRelevanceFieldEnum]


export const DepartmentsOrderByRelevanceFieldEnum = {
  department_name: 'department_name'
} as const

export type DepartmentsOrderByRelevanceFieldEnum = (typeof DepartmentsOrderByRelevanceFieldEnum)[keyof typeof DepartmentsOrderByRelevanceFieldEnum]


export const IssIndicadoresMacroeconomicosOrderByRelevanceFieldEnum = {
  iss_a_o: 'iss_a_o',
  iss_Indicadoresguid: 'iss_Indicadoresguid',
  statecode: 'statecode',
  iss_meses: 'iss_meses',
  iss_trimestre: 'iss_trimestre'
} as const

export type IssIndicadoresMacroeconomicosOrderByRelevanceFieldEnum = (typeof IssIndicadoresMacroeconomicosOrderByRelevanceFieldEnum)[keyof typeof IssIndicadoresMacroeconomicosOrderByRelevanceFieldEnum]


export const IssRecoleccionProyectosOrderByRelevanceFieldEnum = {
  iss_ProyectoPeriodGuid: 'iss_ProyectoPeriodGuid',
  iss_ApartamentooCasaModelo: 'iss_ApartamentooCasaModelo',
  iss_EngancheFraccionado: 'iss_EngancheFraccionado',
  iss_ModalidadFHA: 'iss_ModalidadFHA',
  iss_NombredelProyecto: 'iss_NombredelProyecto',
  iss_Periodo: 'iss_Periodo',
  iss_ProyectoGuid: 'iss_ProyectoGuid',
  statuscode: 'statuscode',
  iss_revitalizado: 'iss_revitalizado',
  iss_showroom: 'iss_showroom',
  iss_tipodemarketscan: 'iss_tipodemarketscan',
  iss_torreofase: 'iss_torreofase',
  iss_uso: 'iss_uso',
  iss_clasificacionporzona: 'iss_clasificacionporzona',
  iss_pais: 'iss_pais',
  iss_barrio: 'iss_barrio',
  iss_barriocr: 'iss_barriocr',
  iss_canton: 'iss_canton',
  iss_cantoncr: 'iss_cantoncr',
  iss_categoria: 'iss_categoria',
  iss_categoriaoriginal: 'iss_categoriaoriginal',
  iss_colonia: 'iss_colonia',
  iss_departamento: 'iss_departamento',
  iss_distrito: 'iss_distrito',
  iss_latitud: 'iss_latitud',
  iss_longitud: 'iss_longitud',
  iss_mercadoprimario: 'iss_mercadoprimario',
  iss_mercadosecundario: 'iss_mercadosecundario',
  iss_municipio: 'iss_municipio',
  iss_provinciacr: 'iss_provinciacr',
  iss_subcategoria: 'iss_subcategoria',
  iss_subzona: 'iss_subzona',
  iss_tipoderevitalizado: 'iss_tipoderevitalizado',
  iss_vendido: 'iss_vendido',
  iss_mercadosecundarioincompleto: 'iss_mercadosecundarioincompleto',
  iss_parqueoparacontenedores: 'iss_parqueoparacontenedores',
  iss_zona: 'iss_zona',
  iss_desarrollador: 'iss_desarrollador',
  iss_ConstructoraMovimientoDeTierras: 'iss_ConstructoraMovimientoDeTierras',
  iss_ConstructoraObraGris: 'iss_ConstructoraObraGris',
  iss_ConstructoraAcabados: 'iss_ConstructoraAcabados',
  iss_Constructora4: 'iss_Constructora4',
  iss_Constructora5: 'iss_Constructora5'
} as const

export type IssRecoleccionProyectosOrderByRelevanceFieldEnum = (typeof IssRecoleccionProyectosOrderByRelevanceFieldEnum)[keyof typeof IssRecoleccionProyectosOrderByRelevanceFieldEnum]


export const MunicipalitiesOrderByRelevanceFieldEnum = {
  municipality_name: 'municipality_name'
} as const

export type MunicipalitiesOrderByRelevanceFieldEnum = (typeof MunicipalitiesOrderByRelevanceFieldEnum)[keyof typeof MunicipalitiesOrderByRelevanceFieldEnum]


export const MunicipioOrderByRelevanceFieldEnum = {
  municipio: 'municipio'
} as const

export type MunicipioOrderByRelevanceFieldEnum = (typeof MunicipioOrderByRelevanceFieldEnum)[keyof typeof MunicipioOrderByRelevanceFieldEnum]


export const ProjectsOrderByRelevanceFieldEnum = {
  project_name: 'project_name',
  project_uuid: 'project_uuid',
  project_longitude: 'project_longitude',
  project_latitude: 'project_latitude'
} as const

export type ProjectsOrderByRelevanceFieldEnum = (typeof ProjectsOrderByRelevanceFieldEnum)[keyof typeof ProjectsOrderByRelevanceFieldEnum]


export const ProjectsVersionsOrderByRelevanceFieldEnum = {
  project_version_uuid: 'project_version_uuid',
  project_name: 'project_name',
  project_uuid: 'project_uuid'
} as const

export type ProjectsVersionsOrderByRelevanceFieldEnum = (typeof ProjectsVersionsOrderByRelevanceFieldEnum)[keyof typeof ProjectsVersionsOrderByRelevanceFieldEnum]


export const ProyectStatusOrderByRelevanceFieldEnum = {
  name: 'name'
} as const

export type ProyectStatusOrderByRelevanceFieldEnum = (typeof ProyectStatusOrderByRelevanceFieldEnum)[keyof typeof ProyectStatusOrderByRelevanceFieldEnum]


export const ProyectoOrderByRelevanceFieldEnum = {
  Name: 'Name',
  Uuid: 'Uuid',
  Country: 'Country'
} as const

export type ProyectoOrderByRelevanceFieldEnum = (typeof ProyectoOrderByRelevanceFieldEnum)[keyof typeof ProyectoOrderByRelevanceFieldEnum]


export const ResponseOrderByRelevanceFieldEnum = {
  ResponseId: 'ResponseId',
  Environment: 'Environment'
} as const

export type ResponseOrderByRelevanceFieldEnum = (typeof ResponseOrderByRelevanceFieldEnum)[keyof typeof ResponseOrderByRelevanceFieldEnum]


export const StatusesOrderByRelevanceFieldEnum = {
  status_name: 'status_name'
} as const

export type StatusesOrderByRelevanceFieldEnum = (typeof StatusesOrderByRelevanceFieldEnum)[keyof typeof StatusesOrderByRelevanceFieldEnum]


export const SubCategoriaOrderByRelevanceFieldEnum = {
  subcategoria: 'subcategoria'
} as const

export type SubCategoriaOrderByRelevanceFieldEnum = (typeof SubCategoriaOrderByRelevanceFieldEnum)[keyof typeof SubCategoriaOrderByRelevanceFieldEnum]


export const SubcategoriesOrderByRelevanceFieldEnum = {
  subcategory_name: 'subcategory_name'
} as const

export type SubcategoriesOrderByRelevanceFieldEnum = (typeof SubcategoriesOrderByRelevanceFieldEnum)[keyof typeof SubcategoriesOrderByRelevanceFieldEnum]


export const UnidadesOrderByRelevanceFieldEnum = {
  Name: 'Name',
  Country: 'Country'
} as const

export type UnidadesOrderByRelevanceFieldEnum = (typeof UnidadesOrderByRelevanceFieldEnum)[keyof typeof UnidadesOrderByRelevanceFieldEnum]


export const UnitsOrderByRelevanceFieldEnum = {
  unit_name: 'unit_name'
} as const

export type UnitsOrderByRelevanceFieldEnum = (typeof UnitsOrderByRelevanceFieldEnum)[keyof typeof UnitsOrderByRelevanceFieldEnum]


export const UnitsVersionsOrderByRelevanceFieldEnum = {
  unit_version_uuid: 'unit_version_uuid',
  unit_name: 'unit_name',
  project_version_uuid: 'project_version_uuid'
} as const

export type UnitsVersionsOrderByRelevanceFieldEnum = (typeof UnitsVersionsOrderByRelevanceFieldEnum)[keyof typeof UnitsVersionsOrderByRelevanceFieldEnum]


export const UsoOrderByRelevanceFieldEnum = {
  uso: 'uso'
} as const

export type UsoOrderByRelevanceFieldEnum = (typeof UsoOrderByRelevanceFieldEnum)[keyof typeof UsoOrderByRelevanceFieldEnum]


export const ZonaOrderByRelevanceFieldEnum = {
  zona: 'zona'
} as const

export type ZonaOrderByRelevanceFieldEnum = (typeof ZonaOrderByRelevanceFieldEnum)[keyof typeof ZonaOrderByRelevanceFieldEnum]


export const ZonesOrderByRelevanceFieldEnum = {
  zone_name: 'zone_name'
} as const

export type ZonesOrderByRelevanceFieldEnum = (typeof ZonesOrderByRelevanceFieldEnum)[keyof typeof ZonesOrderByRelevanceFieldEnum]


export const housing_amenitiesOrderByRelevanceFieldEnum = {
  proyecto: 'proyecto',
  cod_proyecto: 'cod_proyecto'
} as const

export type housing_amenitiesOrderByRelevanceFieldEnum = (typeof housing_amenitiesOrderByRelevanceFieldEnum)[keyof typeof housing_amenitiesOrderByRelevanceFieldEnum]


export const housing_servicesOrderByRelevanceFieldEnum = {
  proyecto: 'proyecto',
  cod_proyecto: 'cod_proyecto'
} as const

export type housing_servicesOrderByRelevanceFieldEnum = (typeof housing_servicesOrderByRelevanceFieldEnum)[keyof typeof housing_servicesOrderByRelevanceFieldEnum]


export const housing_unitsOrderByRelevanceFieldEnum = {
  proyecto: 'proyecto',
  periodo: 'periodo',
  topografia: 'topografia',
  num_unidad: 'num_unidad',
  modelo: 'modelo',
  torre_fase: 'torre_fase',
  unidad: 'unidad',
  parqueo: 'parqueo',
  tipo_parqueo: 'tipo_parqueo',
  parqueo_moto: 'parqueo_moto',
  uso: 'uso',
  disponibilidad: 'disponibilidad',
  categoria: 'categoria',
  nse: 'nse',
  cod_texto: 'cod_texto',
  cod_proyecto: 'cod_proyecto'
} as const

export type housing_unitsOrderByRelevanceFieldEnum = (typeof housing_unitsOrderByRelevanceFieldEnum)[keyof typeof housing_unitsOrderByRelevanceFieldEnum]


export const housing_universeOrderByRelevanceFieldEnum = {
  cod_proyecto: 'cod_proyecto',
  proyecto: 'proyecto',
  fase: 'fase',
  torre: 'torre',
  periodo: 'periodo',
  categoria: 'categoria',
  pais: 'pais',
  departamento: 'departamento',
  municipio: 'municipio',
  zona: 'zona',
  subzona: 'subzona',
  desarrollador: 'desarrollador',
  estado: 'estado',
  uso: 'uso',
  fha: 'fha',
  tipo_de_seguridad: 'tipo_de_seguridad',
  muvi: 'muvi',
  nse_proyecto: 'nse_proyecto',
  showroom: 'showroom',
  casa_modelo: 'casa_modelo',
  cantidad_accesos: 'cantidad_accesos',
  mercado: 'mercado',
  url_imagen: 'url_imagen'
} as const

export type housing_universeOrderByRelevanceFieldEnum = (typeof housing_universeOrderByRelevanceFieldEnum)[keyof typeof housing_universeOrderByRelevanceFieldEnum]


export const industrial_amenitiesOrderByRelevanceFieldEnum = {
  COD: 'COD'
} as const

export type industrial_amenitiesOrderByRelevanceFieldEnum = (typeof industrial_amenitiesOrderByRelevanceFieldEnum)[keyof typeof industrial_amenitiesOrderByRelevanceFieldEnum]


export const industrial_unitsOrderByRelevanceFieldEnum = {
  COD: 'COD',
  proyecto: 'proyecto',
  periodo: 'periodo',
  no_de_bodega: 'no_de_bodega',
  fase: 'fase',
  sector_cluster: 'sector_cluster',
  categor_a: 'categor_a',
  parqueo_de_vehiculo: 'parqueo_de_vehiculo',
  uso: 'uso',
  Disponible: 'Disponible',
  clasificacion: 'clasificacion'
} as const

export type industrial_unitsOrderByRelevanceFieldEnum = (typeof industrial_unitsOrderByRelevanceFieldEnum)[keyof typeof industrial_unitsOrderByRelevanceFieldEnum]


export const industrial_universeOrderByRelevanceFieldEnum = {
  COD: 'COD',
  proyecto: 'proyecto',
  fase: 'fase',
  sector_cluster: 'sector_cluster',
  periodo: 'periodo',
  categoria: 'categoria',
  desarrollador: 'desarrollador',
  pais: 'pais',
  departamento: 'departamento',
  municipio: 'municipio',
  zona: 'zona',
  estado: 'estado',
  uso: 'uso',
  enfoque: 'enfoque',
  compartido_exclusivo: 'compartido_exclusivo',
  enganche: 'enganche',
  enganche_fraccionado: 'enganche_fraccionado'
} as const

export type industrial_universeOrderByRelevanceFieldEnum = (typeof industrial_universeOrderByRelevanceFieldEnum)[keyof typeof industrial_universeOrderByRelevanceFieldEnum]


export const issAmenidadesOrderByRelevanceFieldEnum = {
  Guid_Proyecto_Amenidades: 'Guid_Proyecto_Amenidades',
  Guid_Proyecto: 'Guid_Proyecto',
  iss_Proyecto: 'iss_Proyecto',
  iss_Amenidad: 'iss_Amenidad'
} as const

export type issAmenidadesOrderByRelevanceFieldEnum = (typeof issAmenidadesOrderByRelevanceFieldEnum)[keyof typeof issAmenidadesOrderByRelevanceFieldEnum]


export const office_amenitiesOrderByRelevanceFieldEnum = {
  proyecto: 'proyecto',
  cod_proyecto: 'cod_proyecto'
} as const

export type office_amenitiesOrderByRelevanceFieldEnum = (typeof office_amenitiesOrderByRelevanceFieldEnum)[keyof typeof office_amenitiesOrderByRelevanceFieldEnum]


export const office_unitsOrderByRelevanceFieldEnum = {
  proyecto: 'proyecto',
  cod_proyecto: 'cod_proyecto',
  periodo: 'periodo',
  no_unidad: 'no_unidad',
  torre: 'torre',
  unidad: 'unidad',
  parqueo_de_vehiculo: 'parqueo_de_vehiculo',
  uso: 'uso',
  disponibilidad: 'disponibilidad',
  cantidad_empleados: 'cantidad_empleados',
  clasificacion_oficina: 'clasificacion_oficina',
  clasificacion_general_por_tama_o: 'clasificacion_general_por_tama_o',
  leyenda_cantidad_empleados: 'leyenda_cantidad_empleados',
  leyenda_cantidad_m2: 'leyenda_cantidad_m2',
  leyenda_tama_o_cantidad_empleados: 'leyenda_tama_o_cantidad_empleados',
  leyenda_tama_o_m2: 'leyenda_tama_o_m2'
} as const

export type office_unitsOrderByRelevanceFieldEnum = (typeof office_unitsOrderByRelevanceFieldEnum)[keyof typeof office_unitsOrderByRelevanceFieldEnum]


export const office_universeOrderByRelevanceFieldEnum = {
  cod_proyecto: 'cod_proyecto',
  proyecto: 'proyecto',
  periodo: 'periodo',
  enfoque_principal: 'enfoque_principal',
  enfoque_secundario: 'enfoque_secundario',
  desarrollador: 'desarrollador',
  pais: 'pais',
  zona: 'zona',
  estado: 'estado',
  uso: 'uso',
  enganche: 'enganche',
  enganche_fraccionado: 'enganche_fraccionado'
} as const

export type office_universeOrderByRelevanceFieldEnum = (typeof office_universeOrderByRelevanceFieldEnum)[keyof typeof office_universeOrderByRelevanceFieldEnum]



/**
 * Field references
 */


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}


export type Datasource = {
  url?: string
}
export type Datasources = {
  db?: Datasource
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasources?: Datasources
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasourceUrl?: string
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
   */
  adapter?: runtime.SqlDriverAdapterFactory | null
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
}
export type GlobalOmitConfig = {
  applications?: Prisma.ApplicationsOmit
  categoria?: Prisma.CategoriaOmit
  categories?: Prisma.CategoriesOmit
  comment?: Prisma.CommentOmit
  configs?: Prisma.ConfigsOmit
  departamento?: Prisma.DepartamentoOmit
  departments?: Prisma.DepartmentsOmit
  issIndicadoresMacroeconomicos?: Prisma.IssIndicadoresMacroeconomicosOmit
  issRecoleccionProyectos?: Prisma.IssRecoleccionProyectosOmit
  municipalities?: Prisma.MunicipalitiesOmit
  municipio?: Prisma.MunicipioOmit
  projects?: Prisma.ProjectsOmit
  projectsVersions?: Prisma.ProjectsVersionsOmit
  proyectStatus?: Prisma.ProyectStatusOmit
  proyecto?: Prisma.ProyectoOmit
  response?: Prisma.ResponseOmit
  statuses?: Prisma.StatusesOmit
  subCategoria?: Prisma.SubCategoriaOmit
  subcategories?: Prisma.SubcategoriesOmit
  unidades?: Prisma.UnidadesOmit
  units?: Prisma.UnitsOmit
  unitsVersions?: Prisma.UnitsVersionsOmit
  uso?: Prisma.UsoOmit
  zona?: Prisma.ZonaOmit
  zones?: Prisma.ZonesOmit
  housing_amenities?: Prisma.housing_amenitiesOmit
  housing_services?: Prisma.housing_servicesOmit
  housing_units?: Prisma.housing_unitsOmit
  housing_universe?: Prisma.housing_universeOmit
  industrial_amenities?: Prisma.industrial_amenitiesOmit
  industrial_units?: Prisma.industrial_unitsOmit
  industrial_universe?: Prisma.industrial_universeOmit
  issAmenidades?: Prisma.issAmenidadesOmit
  office_amenities?: Prisma.office_amenitiesOmit
  office_units?: Prisma.office_unitsOmit
  office_universe?: Prisma.office_universeOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

